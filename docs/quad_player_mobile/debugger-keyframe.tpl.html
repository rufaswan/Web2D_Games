<!DOCTYPE html>
<!--
[license]
Copyright (C) 2019 by Rufas Wan

This file is part of Web2D Games.
    <https://github.com/rufaswan/Web2D_Games>

Web2D Games is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Web2D Games is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Web2D Games.  If not, see <http://www.gnu.org/licenses/>.
[/license]
-->

<html xmlns='http://www.w3.org/1999/xhtml'><head>

<meta charset='utf-8' />
<meta name='viewport' content='width=device-width, initial-scale=1' />
<title>Quad Debugger - Keyframe</title>
<script>'use strict';

var APP = {};

APP.get_html_id = function(){
	var html = {};
	var eles = document.querySelectorAll('*[id]');
	for ( var i=0; i < eles.length; i++ ) {
		var id   = eles[i].id;
		html[id] = eles[i];
	}
	return html;
}

APP.qdata_filetable = function( qdata, files ){
	files.innerHTML = '';
	if ( qdata.name )
		files.innerHTML += '<li>[QUAD] ' + qdata.name + '</li>';
	for ( var i=0; i < qdata.image.length; i++ ){
		if ( ! qdata.image[i] || ! qdata.image[i].name )
			continue;
		var img = qdata.image[i];
		files.innerHTML += '<li>[IMAGE][' + i + '] ' + img.name + ' (' + JSON.stringify(img.pos) + ')</li>';
	}
}

APP.process_uploads = function(){
	var proall = [];
	while ( APP.upload_queue.length > 0 ){
		var up = APP.upload_queue.shift();

		if ( typeof up.name !== 'string' )  continue;
		if ( typeof up.data !== 'string' )  continue;

		up.id |= 0;
		if ( up.id < 0 )
			continue;
		if ( ! APP.QuadList[up.id] )
			APP.QuadList[up.id] = new QuadData(APP.QuadList);

		var pro = QUAD.func.queue_promise(up, APP.QuadList[up.id]);
		proall.push(pro);
	} // while ( queue.length > 0 )

	return Promise.all(proall).then(function(res){
		return APP.process_uploads_done();
	});
}
</script>
<style>:root {
	--body-bg-color     : #121212;
	--body-text-color   : #ededed;
	--button-bg-color   : #ededed;
	--button-text-color : #121212;
	--border-color      : #808080;
	--mobile-button-size-small   : 42px; /* 11mm */
	--mobile-button-hspace-small : 18px; /* 36px-48px = 10mm-13mm */
	--mobile-button-vspace-small :  9px;
}
body {
	background-color : var(--body-bg-color);
	overflow         : hidden;
	margin           : 0;
	padding          : 0;
	overflow         : hidden;
}
body, a {
	color       : var(--body-text-color);
	font-family : sans-serif;
}

button {
	background-color : var(--button-bg-color);
	color            : var(--button-text-color);
	white-space      : nowrap;
	text-transform   : uppercase;
	margin           : var(--mobile-button-hspace-small)  var(--mobile-button-vspace-small);
	min-width        : var(--mobile-button-size-small);
	height           : var(--mobile-button-size-small);
	padding          : 0;
	border           : 1px var(--border-color) solid;
	box-sizing       : border-box;
}
button.btn_on {
	background-color : #0f0;
	color            : #000;
}
button.btn_off {
	background-color : #f00;
	color            : #fff;
}

h1, h2, h3, h4, h5, h6 {
	text-transform : uppercase;
	border-bottom  : 1px var(--border-color) solid;
}

ul {
	list-style-type : none;
}

.hidden {
	display : none;
}

main,
main > nav {
	display     : flex;
	position    : relative;
	align-items : stretch;
	margin      : 0;
	padding     : 0;
}
main > nav {
	overflow : hidden scroll;
}
#debugger {
	position : relative;
	overflow : hidden;
}
#debugger #quad_data,
#debugger #layerdata {
	position         : absolute;
	top              : 0;
	left             : 0;
	width            : 100%;
	height           : 100%;
	background-color : var(--body-bg-color);
	color            : var(--body-text-color);
	overflow         : scroll;
}
#debugger #layerdata {
	display : none;
}
#debugger #layerdata div {
	display        : flex;
	flex-direction : row;
	flex-wrap      : nowrap;
	align-items    : center;
	align-content  : stretch;
	margin         : 0;
}
#debugger #layerdata select {
	width  : 90%;
	height : var(--mobile-button-size-small);
}

#viewer {
	position         : relative;
	overflow         : hidden;
	background-color : var(--body-bg-color);
}
#viewer canvas,
#viewer_xline,
#viewer_yline {
	position : absolute;
	top      : 0;
	left     : 0;
}
#viewer_xline {
	width        :  50%;
	height       : 100%;
	border-right : 0.5em var(--border-color) solid;
}
#viewer_yline {
	width         : 100%;
	height        :  75%;
	border-bottom : 0.5em var(--border-color) solid;
}
#viewer canvas {
	width    : 100%;
	height   : 100%;
}

#keylist,
#layerlist {
	margin  : 0;
	padding : 0;
}
#keylist p,
#layerlist p {
	border      : 1px var(--border-color) solid;
	padding     : 0 0.5em;
	line-height : var(--mobile-button-size-small);
}
#layerlist .layer_on {
	background-color : var(--body-text-color);
	color            : var(--body-bg-color);
}

@media (orientation:landscape) {
	main {
		flex-direction : row;
	}
	main > nav {
		flex-direction : column;
		width          :  10vw;
		height         : 100vh;
	}
	#viewer {
		width  :  45vw;
		height : 100vh;
	}
	#debugger {
		width  :  45vw;
		height : 100vh;
	}
}

@media (orientation:portrait) {
	main {
		flex-direction : column;
	}
	main > nav {
		flex-direction : row;
		width          : 100vw;
		height         :  10vh;
	}
	#viewer {
		width  : 100vw;
		height :  45vh;
	}
	#debugger {
		width  : 100vw;
		height :  45vh;
	}
}
</style>
<script>'use strict';

APP.process_uploads_done = function(){
	var qdata = APP.QuadList[ APP.upload_id ];

	APP.qdata_filetable(qdata, APP.html.debugger_files);
	if ( qdata.name ){
		APP.html.keylist.innerHTML = '';
		document.title = '[' + qdata.name + '] ' + APP.html.quad_version.innerHTML;

		if ( ! qdata.quad.keyframe )
			return;
		qdata.attach.type = 'keyframe';

		var buffer = '';
		qdata.quad.keyframe.forEach(function(v,k){
			if ( ! v )
				return;
			var name = v.name + ' (' + v.debug + ')';
			buffer += '<li><p onclick="keyframe_select(' + k + ');">' + name + '</p></li>';
		});
		APP.html.keylist.innerHTML = buffer;
	} // if ( qdata.name )

	APP.autozoom  = 1.0;
	APP.is_redraw = true;
}

APP.button_select_layers = function( text ){
	APP.on_layer = [];
	var list = document.querySelectorAll('#layerlist li');
	for ( var i=0; i < list.length; i++ ){
		var id = list[i].getAttribute('data-id') | 0;
		if ( ! text ){ // select all
			list[i].classList.add('layer_on');
			APP.on_layer.push(id);
		}
		else { // select matched
			var debug = list[i].getAttribute('data-debug');
			if ( debug === text ){
				list[i].classList.add('layer_on');
				APP.on_layer.push(id);
			}
			else { // unmatched are unchanged
				if ( list[i].classList.contains('layer_on') )
					APP.on_layer.push(id);
			}
		}
	} // for ( var i=0; i < list.length; i++ )
}

APP.button_unselect_layers = function( text ){
	APP.on_layer = [];
	var list = document.querySelectorAll('#layerlist li');
	for ( var i=0; i < list.length; i++ ){
		var id = list[i].getAttribute('data-id') | 0;
		if ( ! text ){ // unselect all
			list[i].classList.remove('layer_on');
		}
		else { // unselect matched
			var debug = list[i].getAttribute('data-debug');
			if ( debug === text ){
				list[i].classList.remove('layer_on');
			}
			else { // unmatched are unchanged
				if ( list[i].classList.contains('layer_on') )
					APP.on_layer.push(id);
			}
		}
	} // for ( var i=0; i < list.length; i++ )
}

APP.keydebug_draw = function( qdata, mat4, color ){
	var key = qdata.quad.keyframe[APP.on_key];
	if ( ! key )
		return;
	if ( qdata.is_lines )
		return APP.keydebug_drawline(qdata, key, mat4, color);
	else
		return APP.keydebug_drawtex (qdata, key, mat4, color);
}

APP.keydebug_drawline = function( qdata, key, mat4, color ){
	var clines = [];

	var debug = [];
	var dbg_id;
	key.layer.forEach(function(lv,lk){
		if ( ! lv )
			return;
		if ( APP.on_layer.indexOf(lk) < 0 )
			return;

		dbg_id = debug.indexOf(lv.debug);
		if ( dbg_id < 0 ){
			dbg_id = debug.length;
			debug.push(lv.debug);
			clines[dbg_id] = [];
		}

		var dst = QUAD.math.quad_multi4(mat4, lv.dstquad);
		clines[dbg_id] = clines[dbg_id].concat(dst);
	});

	var color = [
		[1,0,0,1] , [0,1,0,1] , [0,0,1,1] , // rgb
		[0,1,1,1] , [1,0,1,1] , [1,1,0,1] , // cmy
		[0,0,0,1] , [1,1,1,1] ,             // black white
		[0.5,0  ,0  ,1] , [0  ,0.5,0  ,1] , [0  ,0  ,0.5,1] , // 0.5 rgb
		[0  ,0.5,0.5,1] , [0.5,0  ,0.5,1] , [0.5,0.5,0  ,1] , // 0.5 cmy
		[0.5,0.5,0.5,1] , // gray
	];

	QUAD.gl.enable_blend(0);
	clines.forEach(function(cv,ck){
		var cid = qdata.line_index % color.length;
		QUAD.gl.draw_line(cv, color[cid]);
		qdata.line_index++;
	});
}

APP.keydebug_drawtex = function( qdata, key, mat4, color ){
	var dummysrc = [0,0 , 0,0 , 0,0 , 0,0];

	var zrate = 1.0 / (key.layer.length + 1);
	var buf_list = {};
	var depth = 1.0;
	//console.log('key.order',key.order);

	// draw layers by keyframe order
	key.order.forEach(function(ov){
		var lv = key.layer[ov];
		if ( ! lv )
			return;
		if ( APP.on_layer.indexOf(ov) < 0 )
			return;
		depth -= zrate;

		var bid = lv.blend_id | 0;
		if ( ! buf_list[bid] )
			buf_list[bid] = { dst:[] , src:[] , fog:[] , z:[] };
		var ent = buf_list[bid];

		if ( lv.tex_id < 0 || ! qdata.image[lv.tex_id] )
			var src = dummysrc;
		else
			var src = QUAD.math.vram_srcquad(lv.srcquad, qdata.image[lv.tex_id].pos);
		ent.src = ent.src.concat(src);

		var dst = QUAD.math.quad_multi4(mat4, lv.dstquad);
		var xyz = QUAD.math.perspective_quad(dst);
		ent.dst = ent.dst.concat(xyz);

		var clr = QUAD.math.fog_multi4(color, lv.fogquad);
		ent.fog = ent.fog.concat(clr);

		ent.z = ent.z.concat([depth , depth , depth , depth]);
	});
	//console.log('buf_list',buf_list);

	QUAD.gl.enable_depth('LESS');
	for ( var i = -1; i < qdata.quad.blend.length; i++ ){
		if ( ! buf_list[i] ) // no data to draw
			continue;

		if ( i < 0 ) // disable blending
			QUAD.gl.enable_blend(0);
		else {
			if ( ! qdata.quad.blend[i] ) // invalid or unknown blending
				continue;
			QUAD.gl.enable_blend( qdata.quad.blend[i] );
		}

		var bv = buf_list[i];
		QUAD.gl.draw_keyframe( bv.dst, bv.src, bv.fog, bv.z, qdata.vram );
	} // for ( var i = -1; i < qdata.quad.blend.length; i++ )
	QUAD.gl.enable_depth(0);
}

//////////////////////////////
// function aaa()       + onclick='aaa();'
// APP.aaa = function() + var a = APP.aaa();

function keyframe_select( key_id ){
	APP.html.layerdata.style.display      = 'block';
	APP.html.btn_selectall.style.display  = 'block';
	APP.html.btn_selectnone.style.display = 'block';
	APP.html.layerlist.innerHTML  = '';
	APP.html.layer_name.innerHTML = '';

	var key = APP.QuadList[0].quad.keyframe[key_id];
	if ( ! key )
		return;
	APP.html.layer_name.innerHTML = key.name;
	APP.on_key   = key_id;
	APP.on_layer = [];
	APP.QuadList[0].attach.id = key_id;

	var buffer  = '';
	var dbglist = [];
	key.layer.forEach(function(v,k){
		if ( ! v )
			return;
		APP.on_layer.push(k);

		var dbg = '#' + v.debug.replace(/[^a-zA-Z0-9,]/g, '_');
		if ( dbglist.indexOf(dbg) < 0 )
			dbglist.push(dbg);

		var name = 'layer ' + k + ' (' + dbg + ')';
		buffer += '<li class="layer_on" data-id="' + k + '" data-debug="' + dbg + '"><p onclick="layer_select(this);">' + name + '</p></li>';
	});
	APP.html.layerlist.innerHTML = buffer;

	dbglist.sort();
	dbglist.unshift(0);
	var buffer  = '';
	dbglist.forEach(function(v,k){
		if ( ! v )
			buffer += '<option value="0">ALL</option>';
		else
			buffer += '<option>' + v + '</option>';
	});
	APP.html.debuglist.innerHTML = buffer;

	APP.autozoom  = QUAD.func.viewer_autozoom(APP.QuadList[0]);
	APP.is_redraw = true;
}

function layer_select( elem ){
	var layer_id = elem.parentElement.getAttribute('data-id') | 0;
	var idx = APP.on_layer.indexOf(layer_id);
	if ( idx === -1 )
		APP.on_layer.push(layer_id);
	else
		APP.on_layer.splice(idx, 1);

	var list = document.querySelectorAll('#layerlist li');
	for ( var i=0; i < list.length; i++ ){
		var id  = list[i].getAttribute('data-id') | 0;
		var idx = APP.on_layer.indexOf(id);
		if ( idx === -1 )
			list[i].classList.remove('layer_on');
		else
			list[i].classList.add('layer_on');
	}
	APP.is_redraw = true;
}

function layer_close(){
	APP.html.layerdata.style.display      = 'none';
	APP.html.btn_selectall.style.display  = 'none';
	APP.html.btn_selectnone.style.display = 'none';
}
</script>
<script>'use strict';

var QUAD = {};

(function($){

	function QuadGL(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.GL = '';
	__.SHADER = {};
	__.MAX_TEX_SIZE = -1;

	$.init = function( dom ){
		var opt = {
			alpha                 : true,
			antialias             : true,
			depth                 : true,
			premultipliedAlpha    : false,
			preserveDrawingBuffer : true,
			stencil               : false,
		};
		__.GL = dom.getContext('webgl', opt);
		if ( ! __.GL )
			return Q.func.error('WebGL context failed');
		var form = __.GL.getShaderPrecisionFormat(__.GL.FRAGMENT_SHADER, __.GL.HIGH_FLOAT);
		if ( ! form )
			return Q.func.error('Fragment Shader has no highp support');

		var maxsz = $.detect_max_texsize();
		if ( maxsz < 1 )
			return Q.func.error('MAX_TEXTURE_SIZE < 1', maxsz);
		__.MAX_TEX_SIZE = maxsz | 0;
		var vec2_vram = 'vec2(' + maxsz.toFixed(1) + ' , ' + maxsz.toFixed(1) + ')';

		var vert_src, frag_src;
		Q.func.log('WebGL + highp init OK',
			['precision',form.precision],
			['MAX_TEXTURE_SIZE',__.MAX_TEX_SIZE]
		);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2  a_xy;
			uniform    highp  vec2  u_pxsize;

			highp  vec2  xy;
			void main(void){
				xy = a_xy * u_pxsize;
				gl_Position = vec4(xy.x, xy.y, 1.0 , 1.0);
			}
		`;
		frag_src = `
			uniform  highp  vec4  u_color;

			void main(void){
				gl_FragColor = u_color;
			}
		`;
		__.SHADER.lines = __.create_shader('draw lines', vert_src, frag_src);

		//////////////////////////////

		// lowp    = min  8 bit
		// mediump = min 10 bit
		// highp   = min 16 bit
		vert_src = `
			attribute  highp  vec4   a_fog;
			attribute  highp  vec3   a_xyz;
			attribute  highp  vec2   a_uv;
			attribute  lowp   float  a_z;
			uniform    highp  vec2   u_pxsize;
			varying    highp  vec4   v_fog;
			varying    highp  vec2   v_uv;
			varying    highp  float  v_z;

			highp  vec4   fog;
			highp  vec2   xy;
			highp  vec2   uv;
			highp  float  z;
			void main(void){
				z = 1.0 / a_xyz.z;
				fog = a_fog    * z;
				xy  = a_xyz.xy * z * u_pxsize;
				uv  = a_uv     * z;

				v_fog = fog;
				v_uv  = uv;
				v_z   = z;
				gl_Position = vec4(xy.x, xy.y, a_z, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			varying  highp  vec4   v_fog;
			varying  highp  vec2   v_uv;
			varying  highp  float  v_z;

			highp  vec4   fog;
			highp  vec2   uv;
			highp  float  z;
			void main(void){
				z   = 1.0 / v_z;
				fog = v_fog * z;
				uv  = v_uv  * z;
				gl_FragColor = texture2D(u_tex, uv / ${vec2_vram}) * fog;
			}
		`;
		__.SHADER.keyframe = __.create_shader('draw keyframe', vert_src, frag_src);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2   a_xy;
			attribute  highp  vec2   a_uv;
			varying    highp  vec2   v_uv;

			highp  vec2  xy;
			void main(void){
				v_uv = a_uv;
				xy   = a_xy / ${vec2_vram};

				// convert 0.0 to 1.0 => -1.0 to +1.0
				xy = (xy * 2.0) - 1.0;
				gl_Position = vec4(xy.x, xy.y, 1.0, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			uniform  highp  vec2   u_pxsize;
			varying  highp  vec2   v_uv;

			highp  vec2  uv;
			void main(void){
				uv = v_uv * u_pxsize;
				gl_FragColor = texture2D(u_tex, uv);
			}
		`;
		__.SHADER.vram = __.create_shader('draw vram', vert_src, frag_src);

		//////////////////////////////

		return true;
	}

	__.create_shader = function( name, vert_src, frag_src ){
		var vert_shader = __.GL.createShader(__.GL.VERTEX_SHADER);
		__.GL.shaderSource (vert_shader, vert_src);
		__.GL.compileShader(vert_shader);
		var t = __.GL.getShaderParameter(vert_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(vert_shader) );

		var frag_shader = __.GL.createShader(__.GL.FRAGMENT_SHADER);
		__.GL.shaderSource (frag_shader, frag_src);
		__.GL.compileShader(frag_shader);
		var t = __.GL.getShaderParameter(frag_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(frag_shader) );

		var prog = __.GL.createProgram();
		__.GL.attachShader(prog, vert_shader);
		__.GL.attachShader(prog, frag_shader);
		__.GL.linkProgram (prog);
		var t = __.GL.getProgramParameter(prog, __.GL.LINK_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getProgramInfoLog(prog) );

		Q.func.log('shader init', name);
		return prog;
	}

	//////////////////////////////

	$.draw_line = function( quads, color ){
		__.GL.useProgram( __.SHADER.lines );
		var loc = __.shader_loc(__.SHADER.lines, 'a_xy', 'u_pxsize', 'u_color');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		__.GL.lineWidth(2);
		var pxsz = [ 1.0/view[0] , -1.0/view[1] ];

		__.set_vertex_attrib(loc.a_xy, quads, 2);
		__.GL.uniform4fv    (loc.u_color , color);
		__.GL.uniform2fv    (loc.u_pxsize, pxsz);
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var idxlen = quads.length / 2;  // number of x,y
		__.indice_line(idxlen);
	}

	$.draw_keyframe = function( dst, src, fog, z, image ){
		__.GL.useProgram( __.SHADER.keyframe );
		var loc = __.shader_loc(__.SHADER.keyframe, 'a_fog', 'a_xyz', 'a_uv', 'a_z', 'u_pxsize', 'u_tex');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		var pxsz = [ 1.0/view[0] , -1.0/view[1] ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, image.tex);

		__.set_vertex_attrib(loc.a_xyz, dst, 3);
		__.set_vertex_attrib(loc.a_uv , src, 2);
		__.set_vertex_attrib(loc.a_fog, fog, 4);
		__.set_vertex_attrib(loc.a_z  , z  , 1);
		__.GL.uniform2f     (loc.u_pxsize, pxsz[0], pxsz[1]);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var dstlen = dst.length / 3; // number of x,y
		__.indice_quad(dstlen);
	}

	$.draw_vram = function( vram, tex, rect ){
		__.GL.useProgram( __.SHADER.vram );
		var loc = __.shader_loc(__.SHADER.vram, 'a_xy', 'a_uv', 'u_pxsize', 'u_tex');
		var sw = rect[2] - rect[0];
		var sh = rect[3] - rect[1];

		// to be used with canvas - DO NOT flipy !
		var pxsz = [ 1.0/sw , 1.0/sh ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, tex);

		var dst = [
			rect[0] , rect[1] ,
			rect[2] , rect[1] ,
			rect[2] , rect[3] ,
			rect[0] , rect[3] ,
		];
		var src = [0,0 , sw,0 , sw,sh , 0,sh];
		__.set_vertex_attrib(loc.a_xy, dst, 2);
		__.set_vertex_attrib(loc.a_uv, src, 2);
		__.GL.uniform2f     (loc.u_pxsize, pxsz[0], pxsz[1]);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, vram.w, vram.h);

		$.enable_framebuffer(vram.tex);
		__.indice_quad(4);
		$.enable_framebuffer(0);
	}

	__.indice_line = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1 , i+1,i+2 , i+2,i+3 , i+3,i+0);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y   = 8 numbers
		//        = 4 lines = 8 points / indices
		__.GL.drawElements(__.GL.LINES, len/4*8, __.GL.UNSIGNED_SHORT, 0);
	}

	__.indice_quad = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1,i+2 , i+0,i+2,i+3);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y       =  8 numbers
		//        = 4 x,y,z     = 12 numbers
		//        = 2 triangles =  6 points / indices
		__.GL.drawElements(__.GL.TRIANGLES, len/4*6, __.GL.UNSIGNED_SHORT, 0);
	}

	__.shader_loc = function(){
		var shader = arguments[0];
		var loc    = {};
		for ( var i=1; i < arguments.length; i++ )
		{
			var v = arguments[i];
			switch ( v.charAt(0) ){
			case 'a':  loc[v] = __.GL.getAttribLocation (shader, v); break;
			case 'u':  loc[v] = __.GL.getUniformLocation(shader, v); break;
			}
		} // for ( var i=1; i < arguments.length; i++ )
		return loc;
	}

	__.set_vertex_attrib = function( loc, data, v ){
		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ARRAY_BUFFER, new Float32Array(data), __.GL.STATIC_DRAW);
		__.GL.enableVertexAttribArray(loc);
		__.GL.vertexAttribPointer(loc, v, __.GL.FLOAT, false, 0, 0);
	}

	//////////////////////////////

	$.create_texture = function( pow2=true ){
		var tex = __.GL.createTexture();
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);
		if ( pow2 ){
			// power of 2 textures defaults + mipmap support
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_S    , __.GL.REPEAT);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_T    , __.GL.REPEAT);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MIN_FILTER, __.GL.NEAREST_MIPMAP_LINEAR);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MAG_FILTER, __.GL.LINEAR);
		} else {
			// BUG
			//   https://github.com/rufaswan/Web2D_Games/issues/21
			//   many animations have 1 pixel-wide seams, or extra pixels appearing on the edge of fully transparent parts of a quad
			// FIX
			//   https://www.khronos.org/opengl/wiki/Sampler_Object
			//   If __.GL.NEAREST is used, the implementation will select the texel nearest the texture coordinate; this is commonly called "point sampling".
			//   If __.GL.LINEAR  is used, the implementation will perform a weighted linear blend between the nearest adjacent samples.
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_S    , __.GL.CLAMP_TO_EDGE);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_T    , __.GL.CLAMP_TO_EDGE);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MIN_FILTER, __.GL.LINEAR);
			__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MAG_FILTER, __.GL.LINEAR);
		}
		return tex;
	}

	$.update_texture = function( tex, img ){
		if ( ! tex )
			return Q.func.error('update_texture() has no tex');
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level , internalformat
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
		img);
	}

	$.create_vram = function( rgb , alp ){
		rgb = Q.math.clamp(rgb, 0, 255) | 0;
		alp = Q.math.clamp(alp, 0, 255) | 0;
		var pix = {
			w : __.MAX_TEX_SIZE ,
			h : __.MAX_TEX_SIZE ,
			tex : $.create_texture(1) ,
		};

		var size  = pix.w * pix.h * 4;
		var uint8 = new Uint8Array(size);
		for ( var i=0; i < size; i += 4 ){
			uint8[i+0] = rgb;
			uint8[i+1] = rgb;
			uint8[i+2] = rgb;
			uint8[i+3] = alp;
		}

		__.GL.bindTexture(__.GL.TEXTURE_2D, pix.tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
			pix.w , pix.h    , 0                   , // width  , height , border
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
			uint8
		);
		__.GL.generateMipmap(__.GL.TEXTURE_2D);
		return pix;
	}

	$.to_uint8 = function(){
		return new Promise(function(ok,err){
			__.GL.canvas.toBlob(function(blob){
				var reader = new FileReader;
				reader.onload = function(){
					var uint8 = new Uint8Array(reader.result);
					ok(uint8);
				};
				reader.readAsArrayBuffer(blob);
			}, 'image/png');
		});
	}

	$.read_RGBA = function(){
		var bw = __.GL.drawingBufferWidth;
		var bh = __.GL.drawingBufferHeight;
		var buf = new Uint8Array( bw * bh * 4 );
		__.GL.readPixels(0, 0, bw, bh, __.GL.RGBA, __.GL.UNSIGNED_BYTE, buf);

		var pix = new Uint8Array( 12 + (bw * bh * 4) );
		Q.binary.setint(pix, 0, 4, 0x41424752); // RGBA
		Q.binary.setint(pix, 4, 4, bw);
		Q.binary.setint(pix, 8, 4, bh);

		// vflip the image
		var row = bw * 4;
		for ( var dy=0; dy < bh; dy++ ){
			var dyy = 12 + (dy * row);
			var syy = (bh - 1 - dy) * row;

			for ( var x=0; x < row; x++ ){
				pix[dyy] = buf[syy];
				dyy++;
				syy++;
			}
		} // for ( var dy=0; dy < bh; dy++ )
		return pix;
	}

	//////////////////////////////

	$.enable_blend = function( blend ){
		if ( ! blend )
			return __.GL.disable(__.GL.BLEND);

		var c = blend.color;
		__.GL.blendColor(c[0], c[1], c[2], c[3]);

		if ( ! blend.mode_alpha )
			blend.mode_alpha = blend.mode_rgb;

		var mc = blend.mode_rgb;
		var ma = blend.mode_alpha;
		__.GL.blendEquationSeparate(__.GL[ mc[0] ] , __.GL[ ma[0] ]);
		__.GL.blendFuncSeparate    (__.GL[ mc[1] ] , __.GL[ mc[2] ] , __.GL[ ma[1] ] , __.GL[ ma[2] ]);
		return __.GL.enable(__.GL.BLEND);
	}

	$.enable_depth = function( depth ){
		if ( ! depth ){
			__.GL.clear(__.GL.DEPTH_BUFFER_BIT);
			//__.GL.depthMask(true); // can write depth
			__.GL.clearDepth(1.0);
			return __.GL.disable(__.GL.DEPTH_TEST);
		}

		__.GL.depthFunc(__.GL[depth]);
		return __.GL.enable(__.GL.DEPTH_TEST);
	}

	$.enable_framebuffer = function( tex ){
		if ( ! tex ){
			__.GL.bindFramebuffer(__.GL.FRAMEBUFFER, null);
			return null;
		}

		var fb = __.GL.createFramebuffer();
		__.GL.bindFramebuffer     (__.GL.FRAMEBUFFER, fb);
		__.GL.framebufferTexture2D(__.GL.FRAMEBUFFER, __.GL.COLOR_ATTACHMENT0, __.GL.TEXTURE_2D, tex, 0);
		var t = __.GL.checkFramebufferStatus(__.GL.FRAMEBUFFER);
		if ( t === __.GL.FRAMEBUFFER_COMPLETE ){
			Q.func.log('framebuffer OK');
			return fb;
		}
		return Q.func.error('framebuffer failed',t);
	}

	$.clear = function(){
		__.GL.clear(__.GL.COLOR_BUFFER_BIT);
		//__.GL.colorMask(true , true , true , true); // can write red, green, blue, alpha
		__.GL.clearColor(0 , 0 , 0 , 0);
		__.GL.flush();
	}

	$.is_gl_enum = function( str ){
		if ( Array.isArray(str) ){
			for ( var i=0; i < str.length; i++ ){
				str[i] = $.is_gl_enum(str[i]);
				if ( ! str[i] ) // return when one failed
					return 0;
			}
			return str; // all ok
		}
		if ( typeof str !== 'string' )
			return 0;
		var t = str.toUpperCase();
		return ( __.GL[t] ) ? t : 0;
	}

	//////////////////////////////

	$.drawingbuffer_size = function( max ){
		return [ __.GL.drawingBufferWidth , __.GL.drawingBufferHeight ];
	}

	$.detect_max_texsize = function(){
		var tex = $.create_texture(0);
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);

		var maxsz = __.GL.getParameter( __.GL.MAX_TEXTURE_SIZE ) >> 1;
		while ( ! Q.math.is_int_pow2(maxsz) )
			maxsz--;
		var bw = __.GL.canvas.width;
		var bh = __.GL.canvas.height;

		if ( maxsz < 0 )
			maxsz = 0;
		while ( maxsz > 0 ){
			// test if reading texture at this size
			__.GL.texImage2D(
				__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
				maxsz , maxsz    , 0                   , // width  , height , border
				__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
				null
			);
			// test if writing canvas at this size
			__.GL.canvas.width  = maxsz;
			__.GL.canvas.height = maxsz;

			var error = 0;
			error |= ( __.GL.getError()    !== __.GL.NO_ERROR            );
			error |= ( __.GL.canvas.width  >   __.GL.drawingBufferWidth  );
			error |= ( __.GL.canvas.height >   __.GL.drawingBufferHeight );
			if ( error === 0 )
				break;

			// has error, halved maxsz and test again
			maxsz >>= 1;
		} // while ( maxsz > 0 )

		// restore canvas size after testing
		__.GL.canvas.width  = bw;
		__.GL.canvas.height = bh;
		return maxsz;
	}

	$.max_texsize = function(){
		return __.MAX_TEX_SIZE;
	}
	$.is_max_texsize = function(w, h){
		if ( w > __.MAX_TEX_SIZE || h > __.MAX_TEX_SIZE )
			return false;
		return true;
	}

	$.canvas_size = function(){
		return [ __.GL.canvas.width * 0.5 , __.GL.canvas.height * 0.5 ];
	}

	$.is_canvas_resized = function(){
		// display.block = [w,h] , display.none = [0,0]
		var c = 0;
		c |= ( __.GL.canvas.width  !== __.GL.canvas.clientWidth  );
		c |= ( __.GL.canvas.height !== __.GL.canvas.clientHeight );

		if ( c ){
			__.GL.canvas.width  = __.GL.canvas.clientWidth;
			__.GL.canvas.height = __.GL.canvas.clientHeight;
		}
		return c;
	}

	//////////////////////////////

} // function QuadGL

	function QuadFunc(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.LOGS = [];
	$.log = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return true;
	}
	$.error = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( 'ERROR : ' + txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return false;
	}
	$.console = function(){
		return __.LOGS.join("\n\n");
	}

	$.is_array = function( array, size ){
		if ( ! Array.isArray(array) )
			return false;
		if ( array.length !== size )
			return false;
		return true;
	}
	$.is_array_unique = function( array ){
		if ( ! Array.isArray(array) )
			return false;
		for ( var i=0; i < array.length; i++){
			var idx = array.indexOf( array[i] );
			if ( idx !== i )
				return false;
		}
		return true;
	}
	$.array_clean_null = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list[len] === 0 )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_clean_dups = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list.indexOf( list[len] ) !== len )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_repeat = function( size, value, step=0 ){
		var res = [];
		for ( var i=0; i < size; i++ ){
			res.push(value);
			if ( step )
				value += step;
		}
		return res;
	}

	$.is_undef = function( a ){
		return ( typeof a === 'undefined' );
	}
	$.file_extension = function( fn ){
		var ext = fn.split('.').pop();
		return ext.toLowerCase();
	}
	$.copy_object = function( obj ){
		return JSON.parse( JSON.stringify(obj) );
	}

	$.is_attr_on = function( onlist, attrlist ){
		if ( ! Array.isArray(attrlist) )
			return true;
		for ( var i=0; i < attrlist.length; i++ ){
			var ind = attrlist[i];
			if ( ! onlist[ind] )
				return false;
		}
		return true;
	}

	//////////////////////////////

	$.upload_promise = function( up, id, queue ){
		var ext = $.file_extension(up.name);
		switch ( ext ){
			case 'zip':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						var list = Q.binary.zipread( reader.result );
						ok(list);
					}
					reader.readAsArrayBuffer(up);
				}).then(function(list){
					var proall = [];
					Object.keys(list).forEach(function(fn){
						var ext = $.file_extension(fn);
						switch ( ext ){
							case 'quad':
								var p = new Promise(function(ok,err){
									var blob = new Blob(
										[ list[fn] ],
										{ type : 'text/plain' }
									);
									var reader = new FileReader;
									reader.onload = function(){
										ok([fn,reader.result]);
									}
									reader.readAsText(blob);
								}).then(function(res){
									queue.push({ id : id , name : res[0] , data : res[1] });
								});
								proall.push(p);
								break;
							case 'png':
								var p = new Promise(function(ok,err){
									var blob = new Blob(
										[ list[fn] ],
										{ type : 'image/png' }
									);
									var reader = new FileReader;
									reader.onload = function(){
										ok([fn,reader.result]);
									}
									reader.readAsDataURL(blob);
								}).then(function(res){
									queue.push({ id : id , name : res[0] , data : res[1] });
								});
								proall.push(p);
								break;
						} // switch ( ext )
					});
					return Promise.all(proall);
				});

			case 'quad':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						ok(reader.result);
					}
					reader.readAsText(up);
				}).then(function(text){
					queue.push({ id : id , name : up.name , data : text });
				});

			case 'png':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						ok(reader.result);
					}
					reader.readAsDataURL(up);
				}).then(function(data){
					queue.push({ id : id , name : up.name , data : data });
				});
		} // switch ( ext )
	}

	__.is_rect_collide = function( rect, list ){
		function collide( rect1, rect2 ){
			if ( rect1[0] >= rect2[2] )  return false; // r1.x1 >= r2.x2 , over right
			if ( rect1[1] >= rect2[3] )  return false; // r1.y1 >= r2.y2 , over bottom
			if ( rect1[2] <= rect2[0] )  return false; // r1.x2 <= r2.x1 , over left
			if ( rect1[3] <= rect2[1] )  return false; // r1.y2 <= r2.y1 , over top
			return true;
		}
		for ( var i=0; i < list.length; i++ ){
			if ( ! list[i] )
				continue;
			var col = collide(rect, list[i].pos);
			if ( col )
				return true;
		}
		return false;
	}

	__.vram_posrect = function( vram, texsz, list ){
		for ( var y=0; y < vram.h; y += 0x80 ){
			var y2 = y + texsz[1];
			if ( y2 > vram.h )
				continue;

			for ( var x=0; x < vram.w; x += 0x80 ){
				if ( x === 0 && y === 0 ) // reserve white pixel for fog
					continue;
				var x2 = x + texsz[0];
				if ( x2 > vram.w )
					continue;

				var rect = [x , y , x2 , y2];
				var col = __.is_rect_collide(rect, list);
				if ( ! col )
					return rect;
			} // for ( var x = 0x80; x < vram.w; x += 0x80 )
		} // for ( var y = 0x80; y < vram.h; y += 0x80 )

		// failed to allocate VRAM
		return 0;
	}

	$.queue_promise = function( up, qdata ){
		var ext = $.file_extension(up.name);
		switch ( ext ){
			case 'quad':
				var quad   = JSON.parse(up.data);
				qdata.quad = Q.verify.verify_quadfile(quad);
				qdata.name = Q.verify.safename(up.name);

				qdata.colorize = $.array_repeat(qdata.quad.__ATTR.colorize.length , [1.0 ,1.0 , 1.0 , 1.0]);
				qdata.keyattr  = $.array_repeat(qdata.quad.__ATTR.keyframe.length , true);
				qdata.hitattr  = $.array_repeat(qdata.quad.__ATTR.hitbox.length   , true);
				return $.log('UPLOAD quad', up.name);

			case 'png':
				var name = up.name.match(/\.([0-9]+)\./);
				if ( ! name )
					return 0;

				return new Promise(function(ok,err){
					var tid = name[1];

					var img = new Image;
					img.onload = function(){
						ok([tid,img]);
					}
					img.src = up.data;
				}).then(function(res){
					var tid = res[0];
					var img = res[1];

					var tex = Q.gl.create_texture(0);
					Q.gl.update_texture(tex, img);
					return [tid,tex,img.width,img.height];
				}).then(function(res){
					var tid = res[0];
					var tex = res[1];
					var w = res[2];
					var h = res[3];

					// remove loaded texture
					qdata.image[tid] = 0;
					var pos = __.vram_posrect( qdata.vram , [w,h] , qdata.image );
					if ( ! pos )
						return $.error('cannot fit texture into VRAM', [qdata.vram.w,qdata.vram.h] , [w,h] , qdata.image);

					Q.gl.enable_blend(0);
					Q.gl.draw_vram(qdata.vram, tex, pos);
					qdata.image[tid] = {
						pos  : pos,
						name : up.name,
					};
					return $.log('UPLOAD image', tid, qdata.image[tid]);
				});
		} // switch ( ext )
	}

	//////////////////////////////

	__.draw_lines = function( qdata, layer, mat4, quad ){
		var clines = [];

		var debug = [];
		layer.forEach(function(lv,lk){
			if ( ! lv )
				return;

			var dbg_id = debug.indexOf(lv.debug);
			if ( dbg_id < 0 ){
				dbg_id = debug.length;
				debug.push(lv.debug);
				clines[dbg_id] = [];
			}

			var dst = Q.math.quad_multi4(mat4, lv[quad]);
			clines[dbg_id] = clines[dbg_id].concat(dst);
		});

		var color = [
			[1,0,0,1] , [0,1,0,1] , [0,0,1,1] , // rgb
			[0,1,1,1] , [1,0,1,1] , [1,1,0,1] , // cmy
			[0,0,0,1] , [1,1,1,1] ,             // black white
			[0.5,0  ,0  ,1] , [0  ,0.5,0  ,1] , [0  ,0  ,0.5,1] , // 0.5 rgb
			[0  ,0.5,0.5,1] , [0.5,0  ,0.5,1] , [0.5,0.5,0  ,1] , // 0.5 cmy
			[0.5,0.5,0.5,1] , // gray
		];

		Q.gl.enable_blend(0);
		clines.forEach(function(cv,ck){
			var cid = qdata.line_index % color.length;
			Q.gl.draw_line(cv, color[cid]);

			qdata.line_index++;
			qdata.is_draw = true;
		});
	}

	__.draw_hitbox = function( qdata, hid, mat4 ){
		var layer = qdata.quad.hitbox[hid].layer;
		__.draw_lines(qdata, layer, mat4, 'hitquad');
	}

	//////////////////////////////

	__.draw_keyframe_tex = function( qdata, layer, order, mat4, color ){
		var dummysrc = [0,0 , 0,0 , 0,0 , 0,0];

		var zrate = 1.0 / (layer.length + 1);
		var buf_list = {};
		var depth = 1.0;
		//console.log('order',order);

		// draw layers by keyframe order
		order.forEach(function(ov){
			var lv = layer[ov];
			if ( ! lv )
				return;
			if ( ! $.is_attr_on(qdata.keyattr, lv.attribute) )
				return;
			depth -= zrate;

			var bid = lv.blend_id | 0;
			if ( ! buf_list[bid] )
				buf_list[bid] = { dst:[] , src:[] , fog:[] , z:[] };
			var ent = buf_list[bid];

			if ( lv.tex_id < 0 || ! qdata.image[lv.tex_id] || ! lv.srcquad )
				var src = dummysrc;
			else
				var src = Q.math.vram_srcquad(lv.srcquad, qdata.image[lv.tex_id].pos);
			ent.src = ent.src.concat(src);

			var dst = Q.math.quad_multi4(mat4, lv.dstquad);
			var xyz = Q.math.perspective_quad(dst);
			ent.dst = ent.dst.concat(xyz);

			if ( lv.colorize > 0 ){
				var clr = qdata.colorize[lv.colorize];
				clr = Q.math.vec4_multi(clr, color);
				clr = Q.math.fog_multi4(clr, lv.fogquad);
			}
			else
				var clr = Q.math.fog_multi4(color, lv.fogquad);
			ent.fog = ent.fog.concat(clr);

			ent.z = ent.z.concat([depth , depth , depth , depth]);
		});
		//console.log('buf_list',buf_list);

		Q.gl.enable_depth('LESS');
		for ( var i = -1; i < qdata.quad.blend.length; i++ ){
			if ( ! buf_list[i] ) // no data to draw
				continue;

			if ( i < 0 ) // disable blending
				Q.gl.enable_blend(0);
			else {
				if ( ! qdata.quad.blend[i] ) // invalid or unknown blending
					continue;
				Q.gl.enable_blend( qdata.quad.blend[i] );
			}

			qdata.is_draw = true;
			var bv = buf_list[i];
			Q.gl.draw_keyframe( bv.dst, bv.src, bv.fog, bv.z, qdata.vram );
		} // for ( var i = -1; i < qdata.quad.blend.length; i++ )
		Q.gl.enable_depth(0);
	}

	__.draw_keyframe = function( qdata, kid, mat4, color ){
		var key = qdata.quad.keyframe[kid];
		if ( qdata.is_lines )
			return __.draw_lines(qdata, key.layer, mat4, 'dstquad');
		else
			return __.draw_keyframe_tex(qdata, key.layer, key.order, mat4, color);
	}

	//////////////////////////////

	__.draw_MIX = function( qdata, id, mat4, color ){
		var mix = qdata.quad.__MIX[id];
		if ( mix.key ){
			if ( qdata.is_lines )
				__.draw_lines(qdata, mix.key.layer, mat4, 'dstquad');
			else
				__.draw_keyframe_tex(qdata, mix.key.layer, mix.key.order, mat4, color);
		}
		if ( mix.hit && qdata.is_hits )
			__.draw_lines(qdata, mix.hit.layer, mat4, 'hitquad');
	}

	__.attach_keyhit_id = function( qdata, attach ){
		var def = {
			key : -1,
			hit   : -1,
		};
		if ( ! attach )
			return def;

		switch ( attach.type ){
			case 'keyframe':
				def.key = attach.id;
				break;
			case 'hitbox':
				def.hit = attach.id;
				break;
			case 'slot':
				var slot = qdata.quad.slot[ attach.id ];
				if ( ! slot )
					break;
				slot.forEach(function(sv,sk){
					var t = __.attach_keyhit_id(qdata, sv);
					if ( t.key >= 0 )  def.key = t.key;
					if ( t.hit >= 0 )  def.hit = t.hit;
				});
				break;
		} // switch ( attach.type )
		return def;
	}

	__.mix_attach = function( qdata, cur, nxt, rate, keymix, hitmix ){
		var cur_id = __.attach_keyhit_id(qdata, cur);
		var nxt_id = __.attach_keyhit_id(qdata, nxt);

		var mixcur = { key : 0 , hit : 0 };
		var mixnxt = { key : 0 , hit : 0 };

		// duplicate current for updated values
		if ( cur_id.key >= 0 )
			mixcur.key = $.copy_object( qdata.quad.keyframe[cur_id.key] );
		if ( cur_id.hit >= 0 )
			mixcur.hit = $.copy_object( qdata.quad.hitbox  [cur_id.hit] );

		// next is read-only, so reference is fine
		if ( nxt_id.key >= 0 )
			mixnxt.key = qdata.quad.keyframe[nxt_id.key];
		if ( nxt_id.hit >= 0 )
			mixnxt.hit = qdata.quad.hitbox  [nxt_id.hit];

		if ( keymix && mixcur.key && mixnxt.key ){
			if ( mixcur.key.layer.length === mixnxt.key.layer.length ){
				for ( var i=0; i < mixcur.key.layer.length; i++ ){
					if ( ! mixcur.key.layer[i] )
						continue;
					if ( ! mixnxt.key.layer[i] )
						continue;
					mixcur.key.layer[i].dstquad = Q.math.quad_mix( rate , mixcur.key.layer[i].dstquad , mixnxt.key.layer[i].dstquad );
					mixcur.key.layer[i].fogquad = Q.math.fog_mix ( rate , mixcur.key.layer[i].fogquad , mixnxt.key.layer[i].fogquad );
				} // for ( var i=0; i < mixcur.key.layer.length; i++ )
			}
		}

		if ( hitmix && mixcur.hit && mixnxt.hit ){
			if ( mixcur.hit.layer.length === mixnxt.hit.layer.length ){
				for ( var i=0; i < mixcur.hit.layer.length; i++ ){
					if ( ! mixcur.hit.layer[i] )
						continue;
					if ( ! mixnxt.hit.layer[i] )
						continue;
					mixcur.hit.layer[i].hitquad = Q.math.quad_mix( rate , mixcur.hit.layer[i].hitquad , mixnxt.hit.layer[i].hitquad );
				} // for ( var i=0; i < mixcur.hit.layer.length; i++ )
			}
		}

		// return attach object
		var id = qdata.quad.__MIX.length;
		qdata.quad.__MIX.push(mixcur);
		return {
			'type' : '__MIX',
			'id'   : id,
		};
	}

	__.anim_time_index = function( fps, anim ){
		var len = anim.timeline.length;
		var cur = 0;
		while (1){
			fps -= anim.timeline[cur].time;
			if ( fps < 0 )
				return [cur,-fps];

			cur++;
			if ( cur >= len ){
				if ( anim.loop_id < 0 )
					return [-1,0];
				cur = anim.loop_id;
			}
		} // while (1)
	}

	__.anim_current = function( qdata, aid, mat4, color ){
		var ret = {
			attach : 0,
			mat4   : mat4,
			color  : color,
		}

		// check for valid range
		if ( qdata.anim_fps < 0 )
			return ret;
		var anim = qdata.quad.animation[aid];

		// get current frame
		var t = __.anim_time_index(qdata.anim_fps, anim);
		var curid = t[0];
		if ( curid < 0 )
			return ret;
		var cur = anim.timeline[curid];

		// get next frame
		var nxtid = curid + 1;
		if ( nxtid >= anim.timeline.length ){
			if ( anim.loop_id < 0 )
				nxtid = curid;
			else
				nxtid = anim.loop_id;
		}
		var nxt = anim.timeline[nxtid];

		// nothing to mix
		ret.attach = cur.attach;
		if ( curid === nxtid ){
			ret.mat4  = Q.math.matrix_multi44( ret.mat4 , cur.matrix );
			ret.color = Q.math.vec4_multi    ( ret.color, cur.color  );
			return ret;
		}

		// mixing tests
		var m4, c4;
		var rate = t[1] / cur.time;

		// mix matrix
		if ( cur.matrix_mix )
			m4 = Q.math.matrix_mix( rate, cur.matrix, nxt.matrix );
		else
			m4 = cur.matrix;
		ret.mat4 = Q.math.matrix_multi44( ret.mat4 , m4 );

		// mix color
		if ( cur.color_mix )
			c4 = Q.math.color_mix( rate, cur.color , nxt.color  );
		else
			c4 = cur.color;
		ret.color = Q.math.vec4_multi( ret.color, c4 );

		// layer mixing test
		if ( ! cur.keyframe_mix && ! cur.hitbox_mix )
			return ret;

		ret.attach = __.mix_attach(qdata, cur.attach, nxt.attach, rate, cur.keyframe_mix, cur.hitbox_mix);
		return ret;
	}

	//////////////////////////////

	__.draw_skeleton = function( qdata, sid, mat4, color ){
		var bone = qdata.quad.skeleton[sid].bone;
		bone.forEach(function(bv,bk){
			__.draw_attach(qdata, bv.attach, mat4, color);
		});
	}

	//////////////////////////////

	$.is_valid_attach = function( qdata, type, id ){
		if ( ! Array.isArray( qdata.quad[ type ] ) )
			return false;
		if ( ! qdata.quad[ type ][ id ] )
			return false;
		return true;
	}

	__.draw_attach = function( qdata, attach, mat4, color ){
		if ( ! $.is_valid_attach(qdata, attach.type, attach.id) )
			return;
		switch ( attach.type ){
			case 'keyframe':
				return __.draw_keyframe( qdata, attach.id, mat4, color );
			case 'animation':
				var t = __.anim_current( qdata, attach.id, mat4, color );
				if ( ! t.attach )
					return;
				return __.draw_attach( qdata, t.attach, t.mat4, t.color );
			case 'slot':
				qdata.quad.slot[ attach.id ].forEach(function(sv,sk){
					__.draw_attach(qdata, sv, mat4, color);
				});
				return;
			case 'hitbox':
				if ( ! qdata.is_hits )
					return;
				return __.draw_hitbox( qdata, attach.id, mat4 );
			case 'skeleton':
				return __.draw_skeleton( qdata, attach.id, mat4, color );
			case '__MIX':
				return __.draw_MIX( qdata, attach.id, mat4, color );
			case 'list':
				var qid = qdata.quad.list[ attach.id ];
				if ( $.is_undef(qid) || qid < 0 )
					return;
				return $.qdata_draw( qdata.list[qid], mat4, color );
		} // switch ( attach.type )
	}

	$.qdata_draw = function( qdata, mat4, color ){
		if ( ! qdata.quad )
			return;
		var m4 = Q.math.matrix_multi44( mat4, qdata.matrix );
		var c4 = Q.math.vec4_multi(color, qdata.color);
		return __.draw_attach(qdata, qdata.attach, m4, c4);
	}

	$.qdata_clear = function( qdata ){
		if ( ! qdata.quad )
			return;
		Q.gl.clear();
		qdata.is_draw    = false;
		qdata.line_index = 0;
		qdata.quad.__MIX = [];
	}

	$.viewer_autozoom = function( qdata ){
		var canvsz  = Q.gl.canvas_size();
		var sprsize = Q.export.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		if ( ! sprsize )
			return 1.0;

		var symm = Q.math.rect_symmetry(sprsize);
		var zoomx = (canvsz[0] * 1.0) / symm[0];
		var zoomy = (canvsz[1] * 1.5) / symm[1];
		return ( zoomx < zoomy ) ? zoomx : zoomy;
	}

	$.viewer_camera = function( qdata, autozoom ){
		var canvsz = Q.gl.canvas_size();

		qdata.zoom = 1.0;
		var movex = canvsz[0] * 0  ; // no change
		var movey = canvsz[1] * 0.5; // half downward

		if ( autozoom > 0.0 )
			qdata.zoom = autozoom;
		else
			qdata.zoom = $.viewer_autozoom(qdata);

		var m4 = Q.math.matrix4();
		m4[0+3] = movex;
		m4[4+3] = movey;

		m4[0+0] = qdata.zoom;
		m4[4+1] = qdata.zoom;
		if ( qdata.is_flipx )  m4[0+0] = -m4[0+0];
		if ( qdata.is_flipy )  m4[4+1] = -m4[4+1];
		return m4;
	}

	//////////////////////////////

} // function QuadFunc(Q)

	function QuadMath(Q){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.is_int_pow2 = function( int ){
		// 100 & ff === 0
		var rem = int & (int - 1);
		return ( rem === 0 );
	}

	$.clamp = function( n, min, max ){
		if ( n < min )  return min;
		if ( n > max )  return max;
		return n;
	}

	$.rect_symmetry = function( rect ){
		var abs = [
			Math.abs(rect[0]) , Math.abs(rect[1]) ,
			Math.abs(rect[2]) , Math.abs(rect[3]) ,
		];
		var maxx = ( abs[0] > abs[2] ) ? abs[0] : abs[2];
		var maxy = ( abs[1] > abs[3] ) ? abs[1] : abs[3];
		return [ maxx , maxy ];
	}

	$.vram_srcquad = function( quad, pos ){
		if ( ! quad )  return 0; // fog color only
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			xy4[i+0] = quad[i+0] + pos[0];
			xy4[i+1] = quad[i+1] + pos[1];
		}
		return xy4;
	}

	$.css_color = function( css ){
		// css = '#rrggbbaa'
		if ( typeof css !== 'string' || ! /^#[0-9a-fA-F]{8}$/.test(css) )
			return [1,1,1,1];

		var div = 1.0 / 255;
		var rgba = [
			parseInt( css.substring(1,3) , 16 ) * div ,
			parseInt( css.substring(3,5) , 16 ) * div ,
			parseInt( css.substring(5,7) , 16 ) * div ,
			parseInt( css.substring(7,9) , 16 ) * div ,
		];
		return rgba;
	}

	//////////////////////////////

	$.vec_resize = function( len, vec ){
		if ( ! Array.isArray(vec) )
			return;
		while ( vec.length < len )
			vec.push(1);
		while ( vec.length > len ){
			var last = vec.pop() || 1.0;
			var z = ( last == 0 ) ? 0 : 1.0 / last;
			for ( var i=0; i < vec.length; i++ )
				vec[i] *= z;
		} // while ( vec.length > len )
	}

	$.vec_multi = function( v, f ){
		if ( ! Array.isArray(v) )
			return;
		for ( var i=0; i < v.length; i++ )
			v[i] *= f;
	}

	$.vec4_multi = function( v1, v2 ){
		var v4 = [
			v1[0] * v2[0],
			v1[1] * v2[1],
			v1[2] * v2[2],
			v1[3] * v2[3],
		];
		return v4;
	}

	//////////////////////////////

	$.matrix4 = function(){
		var m4 = [
			1,0,0,0,
			0,1,0,0,
			0,0,1,0,
			0,0,0,1,
		];
		return m4;
	}

	$.matrix_multi12 = function( v, m ){
		$.vec_resize(2,v);
		var vm = [
			v[0]*m[0] + v[1]*m[2] ,
			v[0]*m[1] + v[1]*m[3] ,
		];
		return vm;
	}

	$.matrix_multi13 = function( v, m ){
		$.vec_resize(3,v);
		var vm = [
			v[0]*m[0] + v[1]*m[3] + v[2]*m[6] ,
			v[0]*m[1] + v[1]*m[4] + v[2]*m[7] ,
			v[0]*m[2] + v[1]*m[5] + v[2]*m[8] ,
		];
		return vm;
	}

	$.matrix_multi14 = function( v, m ){
		$.vec_resize(4,v);
		var vm = [
			v[0]*m[0] + v[1]*m[4] + v[2]*m[ 8] + v[3]*m[12] ,
			v[0]*m[1] + v[1]*m[5] + v[2]*m[ 9] + v[3]*m[13] ,
			v[0]*m[2] + v[1]*m[6] + v[2]*m[10] + v[3]*m[14] ,
			v[0]*m[3] + v[1]*m[7] + v[2]*m[11] + v[3]*m[15] ,
		];
		return vm;
	}

	$.matrix_multi21 = function( m, v ){
		$.vec_resize(2,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] ,
			m[2]*v[0] + m[3]*v[1] ,
		];
		return mv;
	}

	$.matrix_multi31 = function( m, v ){
		$.vec_resize(3,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] + m[2]*v[2] ,
			m[3]*v[0] + m[4]*v[1] + m[5]*v[2] ,
			m[6]*v[0] + m[7]*v[1] + m[8]*v[2] ,
		];
		return mv;
	}

	$.matrix_multi41 = function( m, v ){
		$.vec_resize(4,v);
		var mv = [
			m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3] ,
			m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3] ,
			m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3] ,
			m[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3] ,
		];
		return mv;
	}

	$.matrix_multi22 = function( m2a, m2b ){
		if ( ! m2a && ! m2b )  return 0;
		if ( ! m2a )  return m2b;
		if ( ! m2b )  return m2a;
		var m2 = [
			m2a[0]*m2b[0] + m2a[1]*m2b[2],
			m2a[0]*m2b[1] + m2a[1]*m2b[3],

			m2a[2]*m2b[0] + m2a[3]*m2b[2],
			m2a[2]*m2b[1] + m2a[3]*m2b[3],
		];
		return m2;
	}

	$.matrix_multi33 = function( m3a, m3b ){
		if ( ! m3a && ! m3b )  return 0;
		if ( ! m3a )  return m3b;
		if ( ! m3b )  return m3a;
		var m3 = [
			m3a[0]*m3b[0] + m3a[1]*m3b[3] + m3a[2]*m3b[6],
			m3a[0]*m3b[1] + m3a[1]*m3b[4] + m3a[2]*m3b[7],
			m3a[0]*m3b[2] + m3a[1]*m3b[5] + m3a[2]*m3b[8],

			m3a[3]*m3b[0] + m3a[4]*m3b[3] + m3a[5]*m3b[6],
			m3a[3]*m3b[1] + m3a[4]*m3b[4] + m3a[5]*m3b[7],
			m3a[3]*m3b[2] + m3a[4]*m3b[5] + m3a[5]*m3b[8],

			m3a[6]*m3b[0] + m3a[7]*m3b[3] + m3a[8]*m3b[6],
			m3a[6]*m3b[1] + m3a[7]*m3b[4] + m3a[8]*m3b[7],
			m3a[6]*m3b[2] + m3a[7]*m3b[5] + m3a[8]*m3b[8],
		];
		return m3;
	}

	$.matrix_multi44 = function( m4a, m4b ){
		if ( ! m4a && ! m4b )  return 0;
		if ( ! m4a )  return m4b;
		if ( ! m4b )  return m4a;
		var m4 = [
			m4a[ 0]*m4b[0] + m4a[ 1]*m4b[4] + m4a[ 2]*m4b[ 8] + m4a[ 3]*m4b[12],
			m4a[ 0]*m4b[1] + m4a[ 1]*m4b[5] + m4a[ 2]*m4b[ 9] + m4a[ 3]*m4b[13],
			m4a[ 0]*m4b[2] + m4a[ 1]*m4b[6] + m4a[ 2]*m4b[10] + m4a[ 3]*m4b[14],
			m4a[ 0]*m4b[3] + m4a[ 1]*m4b[7] + m4a[ 2]*m4b[11] + m4a[ 3]*m4b[15],

			m4a[ 4]*m4b[0] + m4a[ 5]*m4b[4] + m4a[ 6]*m4b[ 8] + m4a[ 7]*m4b[12],
			m4a[ 4]*m4b[1] + m4a[ 5]*m4b[5] + m4a[ 6]*m4b[ 9] + m4a[ 7]*m4b[13],
			m4a[ 4]*m4b[2] + m4a[ 5]*m4b[6] + m4a[ 6]*m4b[10] + m4a[ 7]*m4b[14],
			m4a[ 4]*m4b[3] + m4a[ 5]*m4b[7] + m4a[ 6]*m4b[11] + m4a[ 7]*m4b[15],

			m4a[ 8]*m4b[0] + m4a[ 9]*m4b[4] + m4a[10]*m4b[ 8] + m4a[11]*m4b[12],
			m4a[ 8]*m4b[1] + m4a[ 9]*m4b[5] + m4a[10]*m4b[ 9] + m4a[11]*m4b[13],
			m4a[ 8]*m4b[2] + m4a[ 9]*m4b[6] + m4a[10]*m4b[10] + m4a[11]*m4b[14],
			m4a[ 8]*m4b[3] + m4a[ 9]*m4b[7] + m4a[10]*m4b[11] + m4a[11]*m4b[15],

			m4a[12]*m4b[0] + m4a[13]*m4b[4] + m4a[14]*m4b[ 8] + m4a[15]*m4b[12],
			m4a[12]*m4b[1] + m4a[13]*m4b[5] + m4a[14]*m4b[ 9] + m4a[15]*m4b[13],
			m4a[12]*m4b[2] + m4a[13]*m4b[6] + m4a[14]*m4b[10] + m4a[15]*m4b[14],
			m4a[12]*m4b[3] + m4a[13]*m4b[7] + m4a[14]*m4b[11] + m4a[15]*m4b[15],
		];
		return m4;
	}

	$.matrix_det2 = function( m2 ){
		return (m2[0]*m2[3] - m2[1]*m2[2]);
	}

	$.matrix_inv2 = function( m2 ){
		var det = $.matrix_det2(m2);
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var mco = [
			 m2[3] * det_inv , -m2[1] * det_inv ,
			-m2[2] * det_inv ,  m2[0] * det_inv ,
		];
		return mco;
	}

	$.matrix_inv3 = function( m3 ){
		// | 0 1 2 |
		// | 3 4 5 |
		// | 6 7 8 |
		var mdet = [
			$.matrix_det2([ m3[4],m3[5],m3[7],m3[8] ]),
			$.matrix_det2([ m3[3],m3[5],m3[6],m3[8] ]),
			$.matrix_det2([ m3[3],m3[4],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[7],m3[8] ]),
			$.matrix_det2([ m3[0],m3[2],m3[6],m3[8] ]),
			$.matrix_det2([ m3[0],m3[1],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[4],m3[5] ]),
			$.matrix_det2([ m3[0],m3[2],m3[3],m3[5] ]),
			$.matrix_det2([ m3[0],m3[1],m3[3],m3[4] ]),
		];

		var mco = [
			 mdet[0] , -mdet[3] ,  mdet[6] ,
			-mdet[1] ,  mdet[4] , -mdet[7] ,
			 mdet[2] , -mdet[5] ,  mdet[8] ,
		];

		var det = m3[0]*mco[0] + m3[1]*mco[3] + m3[2]*mco[6];
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var i = 9;
		while ( i > 0 ){
			i--;
			mco[i] *= det_inv;
		}
		return mco;
	}

	//////////////////////////////

	$.cross = function( a, b ){
		$.vec_resize(3,a);
		$.vec_resize(3,b);
		// x = y1*z2 - y2*z1
		// y = z1*x2 - z2*x1
		// z = x1*y2 - x2*y1
		var x = a[1]*b[2] - b[1]*a[2];
		var y = a[2]*b[0] - b[2]*a[0];
		var z = a[0]*b[1] - b[0]*a[1];
		return [x,y,z];
	}

	$.point_in_rect = function( c, a, b ){
		if ( c[0] < Math.min(a[0], b[0]) )  return 0;
		if ( c[0] > Math.max(a[0], b[0]) )  return 0;
		if ( c[1] < Math.min(a[1], b[1]) )  return 0;
		if ( c[1] > Math.max(a[1], b[1]) )  return 0;
		return 1;
	}

	$.barycentric_quad = function( quad ){
		var c13  = $.cross( [quad[0],quad[1],1] , [quad[4],quad[5],1] );
		var c24  = $.cross( [quad[2],quad[3],1] , [quad[6],quad[7],1] );
		var bary = $.cross( c13 , c24 );

		if ( bary[2] == 0 )
			return [0,0];
		var z = 1.0 / bary[2];
		return [ bary[0]*z , bary[1]*z ];
	}

	$.quad_center = function( quad ){
		if ( ! quad )
			return 0;
		var res = {
			center : 0 ,
			type   : 0,
		};
		// 11  3  simple
		// 1-  2  bended , ok
		// -1  1  bended , reorder
		// --  0  twisted
		res.center = $.barycentric_quad(quad);
		res.type  |= $.point_in_rect( res.center , [quad[0],quad[1]] , [quad[4],quad[5]] ) << 0;
		res.type  |= $.point_in_rect( res.center , [quad[2],quad[3]] , [quad[6],quad[7]] ) << 1;
		return res;
	}

	$.perspective_mat3 = function( quad ){
		var v = [
			[ quad[0],quad[1],1 ],
			[ quad[2],quad[3],1 ],
			[ quad[4],quad[5],1 ],
			[ quad[6],quad[7],1 ],
		];

		// 0 1
		// 3 2
		var c = [
			$.cross( $.cross(v[0],v[2]) , $.cross(v[1],v[3]) ), // corner-corner
			$.cross( $.cross(v[0],v[1]) , $.cross(v[3],v[2]) ), //    top-bottom
			$.cross( $.cross(v[0],v[3]) , $.cross(v[1],v[2]) ), //   left-right
		];
		var m3 = [
			c[0][0] , c[1][0] , c[2][0] ,
			c[0][1] , c[1][1] , c[2][1] ,
			c[0][2] , c[1][2] , c[2][2] ,
		];
		return m3;
	}

	$.perspective_quad = function( dst ){
		// https://mrl.nyu.edu/~dzorin/ug-graphics/lectures/lecture7/sld024.html
		// matrix * SRC = DST
		//       matrix = DST * SRC_inv
		//          SRC = matrix_inv * DST
		var dst3 = $.perspective_mat3(dst);

		// var SRC     = pre-computed
		// var SRC_inv = pre-computed
		var src3_inv = [
			 0     , 0     ,  0.005 ,
			-0.001 , 0     ,  0.015 ,
			 0     , 0.001 , -0.015 ,
		];
		var mat3 = $.matrix_multi33(dst3, src3_inv);

		var t = [
			$.matrix_multi31( mat3, [10,10] ),
			$.matrix_multi31( mat3, [20,10] ),
			$.matrix_multi31( mat3, [20,20] ),
			$.matrix_multi31( mat3, [10,20] ),
		];
		return [].concat(t[0],t[1],t[2],t[3]);
	}
	/*
	dummy src = [10,10 , 20,10 , 20,20 , 10,20]

		var a = cross( cross([10,10,1] , [20,20,1]) , cross([20,10,1] , [10,20,1]) );
			= cross([-10,10,0] , [-10,10,300])
			= [3000,3000,200]
		var b = cross( cross([10,10,1] , [20,10,1]) , cross([10,20,1] , [20,20,1]) );
			= cross([0,10,-100] , [0,10,-200])
			= [-1000,0,0]
		var c = cross( cross([10,10,1] , [10,20,1]) , cross([20,10,1] , [20,20,1]) );
			= cross([-10,0,100] , [-10,0,200])
			= [0,1000,0]

		var src3 = [
			3000 , -1000 ,    0 ,
			3000 ,     0 , 1000 ,
			 200 ,     0 ,    0 ,
		]
		var src3_inv = [
			 0     , 0     ,  0.005 ,
			-0.001 , 0     ,  0.015 ,
			 0     , 0.001 , -0.015 ,
		]
	 */

	//////////////////////////////

	$.matrix_mix = function( rate, cur, next ){
		if ( ! cur && ! next )  return 0; // both identidy matrix
		if ( ! cur  )  cur  = $.matrix4();
		if ( ! next )  next = $.matrix4();
		// 4/4 = rate 1    = cur * 1    + next * 0
		// 3/4 = rate 0.75 = cur * 0.75 + next * 0.25
		// 2/4 = rate 0.5  = cur * 0.5  + next * 0.5
		// 1/4 = rate 0.25 = cur * 0.25 + next * 0.75
		// 0/4 = rate 0    = cur * 0    + next * 1
		var rev = 1.0 - rate;
		var m4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			m4[i] = (cur[i] * rate) + (next[i] * rev);
		return m4;
	}

	$.color_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.color_mix',cur,next);
		var rev = 1.0 - rate;
		var c4  = [0,0,0,0];
		for ( var i=0; i < 4; i++ )
			c4[i] = (cur[i] * rate) + (next[i] * rev);
		return c4;
	}

	$.quad_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.quad_mix',cur,next);
		var rev = 1.0 - rate;
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i++ )
			xy4[i] = (cur[i] * rate) + (next[i] * rev);
		return xy4;
	}

	$.fog_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.fog_mix',cur,next);
		var rev = 1.0 - rate;
		var f4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			f4[i] = (cur[i] * rate) + (next[i] * rev);
		return f4;
	}

	// order matters
	//   (A*B)*C === A*(B*C)
	//    A*B    !== B*A
	$.rect_multi4 = function( mat4, rect ){
		if ( ! mat4 )  return rect; // mat4=0 is identidy matrix , rect=no change
		var xy2 = [0,0 , 0,0];
		for ( var i=0; i < 4; i += 2 ){
			var x = rect[i+0];
			var y = rect[i+1];
			//         x           y           z=1       w=1
			xy2[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy2[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy2;
	}

	$.quad_multi4 = function( mat4, quad ){
		if ( ! mat4 )  return quad; // mat4=0 is identidy matrix , quad=no change
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			var x = quad[i+0];
			var y = quad[i+1];
			//         x           y           z=1       w=1
			xy4[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy4[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy4;
	}

	// color * fogquad
	$.fog_multi4 = function( color, quad ){
		var c16 = [
			// r                g                   b                   a
			quad[ 0]*color[0] , quad[ 1]*color[1] , quad[ 2]*color[2] , quad[ 3]*color[3] , // c1
			quad[ 4]*color[0] , quad[ 5]*color[1] , quad[ 6]*color[2] , quad[ 7]*color[3] , // c2
			quad[ 8]*color[0] , quad[ 9]*color[1] , quad[10]*color[2] , quad[10]*color[3] , // c3
			quad[12]*color[0] , quad[13]*color[1] , quad[14]*color[2] , quad[15]*color[3] , // c4
		];
		return c16;
	}

	//////////////////////////////

} // function QuadMath

	function QuadVerify(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.ATTR = 0;

	// case insensitive tag matching
	__.object_lowercase_keys = function( obj ){
		if ( typeof obj !== 'object' )
			return;
		if ( Array.isArray(obj) )
			return;

		Object.keys(obj).forEach(function(tag){
			var low = tag.toLowerCase();

			// already lower case
			if ( tag === low )
				return;
			// have lower/upper/mixed case
			if ( typeof obj[low] !== 'undefined' )
				return Q.func.error('QuadVerify', 'dupkey', tag, low);

			// move to lower case
			obj[low] = obj[tag];
		});
	}
	$.safename = function( str ){
		return str.replace(/[^0-9a-zA-Z\u{0080}\u{ffff}]+/gu, ' ');
	}

	__.attrib_list = function( attrib, enumlist ){
		var ret = [];
		function addlist( str ){
			if ( __.is_str(str) ){
				var t   = $.safename(str);
				var idx = enumlist.indexOf(t);
				if ( idx < 0 ){
					idx = enumlist.length;
					enumlist.push(t);
				}
				ret.push(idx);
			}
		} // function addlist( str )

		if ( Array.isArray(attrib) ){
			attrib.forEach(function(av){
				addlist(av);
			});
		}
		else
			addlist(attrib);
		return ( ret.length > 0 ) ? ret : 0;
	}

	__.is_str = function( str ){
		if ( typeof str !== 'string' )
			return false;
		return ( str.length > 0 );
	}

	__.is_str_array = function( arr, num ){
		if ( ! Array.isArray(arr) )
			return false;
		if ( arr.length !== num )
			return false;
		for ( var i=0; i < num; i++ ){
			if ( ! __.is_str(arr[i]) )
				return false;
		}
		return true;
	}

	__.is_num_array = function( arr, num ){
		if ( ! Array.isArray(arr) )
			return false;
		if ( arr.length !== num )
			return false;
		for ( var i=0; i < num; i++ ){
			if ( typeof arr[i] !== 'number' )
				return false;
		}
		return true;
	}

	//////////////////////////////

	__.verify_blend = function( obj, id ){
		var def = {
			name       : 'blend ' + id,
			mode_rgb   : 0,
			mode_alpha : 0,
			color      : [1,1,1,1],
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			switch ( tag ){
				case 'name':
					if ( __.is_str(obj.name) )
						def.name = $.safename(obj.name);
					break;
				case 'mode_rgb':
				case 'mode_alpha':
					if ( ! __.is_str_array( obj[tag], 3) )
						break;
					def[tag] = Q.gl.is_gl_enum( obj[tag] );
					break;
				case 'color':
					def.color = Q.math.css_color(obj.color);
					break;
			} // switch ( tag )
		});

		if ( ! def.mode_rgb )
			return 0;
		if ( ! def.mode_alpha )
			def.mode_alpha = def.mode_rgb;
		return def;
	}

	__.verify_slot = function( obj, id ){
		if ( ! Array.isArray(obj) )
			return 0;
		var def = [];
		obj.forEach(function(ov,ok){
			var t = __.verify_attach(ov);
			if ( t )
				def.push(t);
		});
		return ( def.length > 0 ) ? def : 0;
	}

	__.verify_hitbox_layer = function( obj ){
		var def = {
			debug     : 0,
			hitquad   : 0,
			attribute : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'hitquad':
					if ( ! __.is_num_array(obj.hitquad, 8) ) // 4 xy
						break;
					def.hitquad = obj.hitquad;
					break;
				case 'attribute':
					def.attribute = __.attrib_list(obj.attribute, __.ATTR.hitbox);
					break;
			} // switch(tag)
		});

		if ( ! def.hitquad )
			return 0;
		return def;
	}

	__.verify_hitbox = function( obj, id ){
		var def = {
			debug  : 0,
			name   : 'hitbox ' + id,
			layer  : [],
			__RECT : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			if ( tag[0] === '_' )
				return;
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'name':
					if ( __.is_str(obj.name) )
						def.name = $.safename(obj.name);
					break;
				case 'layer':
					if ( ! Array.isArray(obj.layer) )
						break;
					obj.layer.forEach(function(v,k){
						def.layer[k] = __.verify_keyframe_layer(v);
					});
					obj.layer = 0;
					break;
			} // switch(tag)
		});

		return def;
	}

	__.verify_keyframe_layer = function( obj ){
		var def = {
			debug     : 0,
			dstquad   : 0,
			srcquad   : 0,
			fogquad   : [1,1,1,1 , 1,1,1,1 , 1,1,1,1 , 1,1,1,1],
			tex_id    : -1,
			blend_id  : -1,
			attribute : 0,
			colorize  : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		var concave = {
			dstquad : 0,
			srcquad : 0,
		};
		Object.keys(def).forEach(function(tag){
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'dstquad':
				case 'srcquad':
					if ( ! __.is_num_array(obj[tag], 8) ) // 4 xy
						break;
					var cen = Q.math.quad_center(obj[tag]);
					if ( cen.type === 3 )
						def[tag] = obj[tag];
					else
						concave[tag] = {
							type : cen.type,
							quad : obj[tag],
						};
					break;
				case 'fogquad':
					if ( __.is_str(obj.fogquad) ){
						var c = Q.math.css_color(obj.fogquad);
						def.fogquad = [].concat(c, c, c, c);
						break;
					}
					if ( __.is_str_array(obj.fogquad, 4) ){
						var c0 = Q.math.css_color( obj.fogquad[0] );
						var c1 = Q.math.css_color( obj.fogquad[1] );
						var c2 = Q.math.css_color( obj.fogquad[2] );
						var c3 = Q.math.css_color( obj.fogquad[3] );
						def.fogquad = [].concat(c0, c1, c2, c3);
						break;
					}
					break;
				case 'tex_id':
				case 'blend_id':
					if ( typeof obj[tag] === 'number' )
						def[tag] = obj[tag] | 0;
					break;
				case 'attribute':
					def.attribute = __.attrib_list(obj.attribute, __.ATTR.keyframe);
					break;
				case 'colorize':
					def.colorize  = __.attrib_list(obj.colorize , __.ATTR.colorize);
					break;
			} // switch(tag)
		});

		if ( concave.dstquad !== 0 )
			Q.func.error('removed concave dstquad', concave.dstquad);
		if ( concave.srcquad !== 0 )
			Q.func.error('removed concave srcquad', concave.srcquad);
		if ( ! def.dstquad )
			return 0;
		return def;
	}

	__.verify_keyframe = function( obj, id ){
		var def = {
			debug  : 0,
			name   : 'keyframe ' + id,
			layer  : [],
			order  : [],
			__RECT : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			if ( tag[0] === '_' )
				return;
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'name':
					if ( __.is_str(obj.name) )
						def.name = $.safename(obj.name);
					break;
				case 'layer':
					if ( ! Array.isArray(obj.layer) )
						break;
					obj.layer.forEach(function(v,k){
						def.layer[k] = __.verify_keyframe_layer(v);
					});
					obj.layer = 0;
					break;
				case 'order':
					if ( ! Array.isArray(obj.order) )
						break;
					if ( ! __.is_num_array(obj.order, obj.order.length) )
						break;
					def.order = obj.order;
					break;
			} // switch(tag)
		});

		if ( def.order.length < 1 ){
			for ( var i=0; i < def.layer.length; i++ )
				def.order.push(i);
		}
		return def;
	}

	__.verify_animation_timeline = function( obj ){
		var def = {
			debug        : 0,
			time         : -1,
			attach       : 0,
			matrix       : 0,
			color        : [1,1,1,1],
			matrix_mix   : 0,
			color_mix    : 0,
			keyframe_mix : 0,
			hitbox_mix   : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'time':
					if ( typeof obj.time === 'number' )
						def.time = obj.time | 0;
					break;
				case 'attach':
					def.attach = __.verify_attach(obj.attach);
					break;
				case 'matrix':
					if ( ! __.is_num_array(obj.matrix, 16) ) // 4x4 matrix
						break;
					def.matrix = obj.matrix;
					break;
				case 'color':
					def.color = Q.math.css_color(obj.color);
					break;
				case 'matrix_mix':
				case 'color_mix':
				case 'keyframe_mix':
				case 'hitbox_mix':
					def[tag] = obj[tag] | 0;
					break;
			} // switch(tag)
		});

		if ( def.time < 1 )
			return 0;
		return def;
	}

	__.verify_animation = function( obj, id ){
		var def = {
			debug    : 0,
			name     : 'animation ' + id,
			loop_id  : -1,
			timeline : [],
			__RECT   : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			if ( tag[0] === '_' )
				return;
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'name':
					if ( __.is_str(obj.name) )
						def.name = $.safename(obj.name);
					break;
				case 'loop_id':
					if ( typeof obj.loop_id === 'number' )
						def.loop_id = obj.loop_id | 0;
					break;
				case 'timeline':
					if ( ! Array.isArray(obj.timeline) )
						break;
					obj.timeline.forEach(function(v){
						var t = __.verify_animation_timeline(v);
						if ( t )
							def.timeline.push(t);
					});
					obj.timeline = 0;
					break;
			} // switch(tag)
		});

		return def;
	}

	__.verify_skeleton_bone = function( obj ){
		var def = {
			debug  : 0,
			attach : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'attach':
					def.attach = __.verify_attach(obj.attach);
					break;
			} // switch(tag)
		});
		return def;
	}

	__.verify_skeleton = function( obj, id ){
		var def = {
			debug  : 0,
			name   : 'skeleton ' + id,
			bone   : [],
			__RECT : 0,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		Object.keys(def).forEach(function(tag){
			if ( tag[0] === '_' )
				return;
			switch(tag){
				case 'debug':
					def.debug = JSON.stringify(obj.debug || 0);
					break;
				case 'name':
					if ( __.is_str(obj.name) )
						def.name = $.safename(obj.name);
					break;
				case 'bone':
					if ( ! Array.isArray(obj.bone) )
						break;
					obj.bone.forEach(function(v,k){
						def.bone[k] = __.verify_skeleton_bone(v);
					});
					obj.bone = 0;
					break;
			} // switch(tag)
		});

		return def;
	}

	//////////////////////////////

	__.verify_attach = function( obj ){
		var def = {
			type : '',
			id   : -1,
		};
		if ( typeof def !== typeof obj )
			return 0;
		__.object_lowercase_keys(obj);

		if ( ! __.is_str(obj.type) )
			return 0;
		def.type = obj.type.toLowerCase();

		if ( typeof obj.id === 'number' )
			def.id = obj.id | 0;
		if ( def.id < 0 )
			return 0;
		return def;
	}

	__.verify_each = function( tag, obj ){
		var valid = [];
		var func  = 'verify_' + tag;
		if ( ! __[func] )
			return 0;

		var none  = true;
		obj.forEach(function(v,k){
			var t = __[func](v,k);
			if ( t ){
				none = false;
				valid[k] = t;
			}
		});
		return ( none ) ? 0 : valid;
	}

	$.verify_quadfile = function( quad ){
		var valid = {
			blend     : [],
			slot      : [],
			hitbox    : [],
			keyframe  : [],
			animation : [],
			skeleton  : [],
			__MIX     : [],
			__ATTR    : {
				keyframe : [],
				hitbox   : [],
				colorize : [],
			},
		};
		if ( typeof valid !== typeof quad )
			return valid;
		__.object_lowercase_keys(quad);

		__.ATTR = valid.__ATTR;
		Object.keys(valid).forEach(function(tag){
			if ( tag[0] === '_' )
				return;
			if ( ! Array.isArray( quad[tag] ) )
				return;
			valid[tag] = __.verify_each( tag, quad[tag] );
			quad[tag]  = 0;
		});

		valid.tag = quad.tag || 0;
		return valid;
	}

	//////////////////////////////

} // QuadVerify

	function QuadExport(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.rect_compare = function( rect, xy ){
		if ( rect[0] > xy[0] )  rect[0] = xy[0]; // x1
		if ( rect[1] > xy[1] )  rect[1] = xy[1]; // y1
		if ( rect[2] < xy[2] )  rect[2] = xy[2]; // x2
		if ( rect[3] < xy[3] )  rect[3] = xy[3]; // y2
	}

	$.rect_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;

		var max  = 1 << 30;
		var rect = 0;
		var is_null = true;

		var cur = qdata.quad[ type ][ id ];
		switch ( type ){
			case 'keyframe':
			case 'hitbox':
				if ( cur.__RECT )
					return cur.__RECT;

				var quad = '';
				if ( type === 'keyframe' )  quad = 'dstquad';
				if ( type === 'hitbox'   )  quad = 'hitquad';
				cur.layer.forEach(function(lv,lk){
					if ( ! lv || ! lv[quad] )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					var dst = lv[quad];
					for ( var i=0; i < 8; i += 2 ){
						if ( rect[0] > dst[i+0] )  rect[0] = dst[i+0]; // x1
						if ( rect[1] > dst[i+1] )  rect[1] = dst[i+1]; // y1
						if ( rect[2] < dst[i+0] )  rect[2] = dst[i+0]; // x2
						if ( rect[3] < dst[i+1] )  rect[3] = dst[i+1]; // y2
					} // for ( var i=0; i < 8; i += 2 )
				});
				cur.__RECT = rect;
				return rect;

			case 'slot':
				cur.forEach(function(sv,sk){
					var xy = $.rect_attach(qdata, sv.type, sv.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					__.rect_compare(rect, xy);
				});
				return rect;

			case 'animation':
				if ( cur.__RECT )
					return cur.__RECT;

				cur.timeline.forEach(function(tv,tk){
					if ( ! tv.attach )
						return;
					var xy = $.rect_attach(qdata, tv.attach.type, tv.attach.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					var xy2 = Q.math.rect_multi4(tv.matrix, xy);
					var t;
					if ( xy2[0] > xy2[2] ){ // if x1 > x2  swap()
						t = xy2[0];
						xy2[0] = xy[2];
						xy2[2] = t;
					}
					if ( xy2[1] > xy[3] ){ // if y1 > y2  swap()
						t = xy2[1];
						xy2[1] = xy2[3];
						xy2[3] = t;
					}
					__.rect_compare(rect, xy2);
				});
				cur.__RECT = rect;
				return rect;

			case 'skeleton':
				if ( cur.__RECT )
					return cur.__RECT;

				cur.bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var xy = $.rect_attach(qdata, bv.attach.type, bv.attach.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					__.rect_compare(rect, xy);
				});
				cur.__RECT = rect;
				return rect;
		} // switch ( type )
		return 0;
	}

	$.is_loop_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var loop = $.is_loop_attach(qdata, slot[i].type, slot[i].id);
					if ( loop )
						return true;
				}
				return false;
			case 'animation':
				var loop = qdata.quad.animation[id].loop_id;
				if ( loop < 0 )
					return false;
				else
					return true;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var loop = $.is_loop_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( loop )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.is_mix_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var mix = $.is_mix_attach(qdata, slot[i].type, slot[i].id);
					if ( mix )
						return true;
				}
				return false;
			case 'animation':
				var time = qdata.quad.animation[id].timeline;
				for ( var i=0; i < time.length; i++ ){
					var tv = time[i];
					var mix = 0;
					mix |= tv.matrix_mix;
					mix |= tv.color_mix;
					mix |= tv.keyframe_mix;
					mix |= tv.hitbox_mix;
					if ( mix )
						return true;
				}
				return false;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var mix = $.is_mix_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( mix )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.time_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var time = 0;
				for ( var i=0; i < slot.length; i++ ){
					var t = $.time_attach(qdata, slot[i].type, slot[i].id);
					if ( t > time )
						time = t;
				}
				return time;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var time = 0;
				anim.forEach(function(av,ak){
					time += av.time;
				});
				return time;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var time = 0;
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var t = $.time_attach(qdata, bv.attach.type, bv.attach.id);
					if ( t > time )
						time = t;
				});
				return time;
		} // switch ( type )
		return 0;
	}


	$.list_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return [];

		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var list = [];
				slot.forEach(function(sv,sk){
					list.push( sv.type +','+ sv.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var list = [];
				anim.forEach(function(tv,tk){
					if ( ! tv || ! tv.attach )
						return;
					list.push( tv.attach.type +','+ tv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var list = [];
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					list.push( bv.attach.type +','+ bv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
		} // switch ( type )
		return [];
	}

	//////////////////////////////

	__.bak = {};
	__.backup = function( qdata, canvas, type, id, fps, zoom ){
		__.bak = {
			type  : qdata.attach.type ,
			id    : qdata.attach.id   ,
			fps   : qdata.anim_fps    ,
			zoom  : qdata.zoom        ,
			line  : qdata.is_lines    ,
			hit   : qdata.is_hits     ,
			canvw : canvas.width  ,
			canvh : canvas.height ,
			fname : qdata.name + '_' + type + '_' + id + '_' + fps ,
			start : performance.now() ,
		};
		qdata.attach.type = type;
		qdata.attach.id   = id;
		qdata.anim_fps    = fps;
		qdata.zoom        = zoom;
		qdata.is_lines    = false;
		qdata.is_hits     = false;
	}

	__.restore = function( qdata, canvas, fmt ){
		qdata.attach.type = __.bak.type;
		qdata.attach.id   = __.bak.id;
		qdata.anim_fps    = __.bak.fps;
		qdata.zoom        = __.bak.zoom;
		qdata.is_lines    = __.bak.line;
		qdata.is_hits     = __.bak.hit;
		canvas.width      = __.bak.canvw;
		canvas.height     = __.bak.canvh;
		Q.func.log('download' , __.bak.fname , 'fmt' , fmt , 'time' , performance.now() - __.bak.start);
	}

	__.download = function( fname, dataurl ){
		if ( ! fname || ! dataurl )
			return;

		var a = document.createElement('a');
		a.href = dataurl;
		a.setAttribute('download', fname);
		a.setAttribute('target'  , '_blank');
		a.click();
	}

	//////////////////////////////

	__.export_sheet = function( qdata, canvas ){
		var line_spacing = 1.15;
		var spr_rect = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var sprwh = [
			Math.ceil( (spr_rect[2] - spr_rect[0]) * line_spacing * qdata.zoom ),
			Math.ceil( (spr_rect[3] - spr_rect[1]) * line_spacing * qdata.zoom ),
		];
		var sprmid = [
			(spr_rect[2] + spr_rect[0]) * 0.5 * qdata.zoom,
			(spr_rect[3] + spr_rect[1]) * 0.5 * qdata.zoom,
		];

		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();

		var anim_remain = anim_time - qdata.anim_fps;
		var tilecol = 1;
		var tilerow = 1;
		var tile = [
			Math.floor(texsize / sprwh[0]),
			Math.floor(texsize / sprwh[1]),
		];
		if ( tile[0] >= anim_remain )
			tilecol = anim_remain;
		else {
			tilecol = tile[0];
			var y = Math.ceil(anim_remain / tile[0]);
			tilerow = ( y < tile[1] ) ? y : tile[1];
		}
		canvas.width  = tilecol * sprwh[0];
		canvas.height = tilerow * sprwh[1];

		// canvas from -halftex to +halftex
		// sprite 0,0 is at center
		var halfpos = [
			canvas.width * 0.5 , canvas.height * 0.5,
			sprwh[0]     * 0.5 , sprwh[1]      * 0.5,
		];

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];
		Q.func.qdata_clear(qdata);

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		// from -1.0 to +1.0
		for ( var dy = -halfpos[1]; dy < halfpos[1]; dy += sprwh[1] ){
			if ( qdata.anim_fps >= anim_time )
				continue;

			// from -1.0 to +1.0
			for ( var dx = -halfpos[0]; dx < halfpos[0]; dx += sprwh[0] ){
				if ( qdata.anim_fps >= anim_time )
					continue;

				var m4 = Q.math.matrix4();
				m4[0+3] = dx + halfpos[2] - sprmid[0];
				m4[4+3] = dy + halfpos[3] - sprmid[1];
				m4 = Q.math.matrix_multi44(camera, m4);

				qdata.is_draw = false;
				Q.func.qdata_draw(qdata, m4, color);
				qdata.anim_fps++;
			} // for ( var dx = -halfpos[0]; dx < halfpos[0]; dx += sprwh[0] )
		} // for ( var dy = -halfpos[1]; dy < halfpos[1]; dy += sprwh[1] )

		var fn = __.bak.fname + '.sheet.png';
		__.download(fn, canvas.toDataURL('image/png'));
	}

	__.export_zip = function( qdata, canvas, fmt ){
		var spr_rect = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var symm = Q.math.rect_symmetry(spr_rect);

		canvas.width  = Math.ceil(symm[0] * qdata.zoom) * 2 + 4;
		canvas.height = Math.ceil(symm[1] * qdata.zoom) * 2 + 4;

		// same number of sprites as sheet
		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();
		var len  = Math.floor(texsize / canvas.width) * Math.floor(texsize / canvas.height);
		var list = {};

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		var proall = [];
		var i = 0;
		while ( i < len ){
			if ( qdata.anim_fps >= anim_time )
				break;
			Q.func.qdata_clear(qdata);
			Q.func.qdata_draw (qdata, camera, color);

			var p = new Promise(function(ok,err){
				switch ( fmt ){
					case 'png':
						// %06d.png
						var pad = '000000' + qdata.anim_fps + '.png';
						var fn  = pad.substring( pad.length - 10 );
						Q.gl.to_uint8().then(function(res){
							ok([fn,res]);
						});
						break;
					case 'rgba':
						// %06d.rgba
						var pad = '000000' + qdata.anim_fps + '.rgba';
						var arg = [
							pad.substring( pad.length - 11 ),
							Q.gl.read_RGBA()
						];
						ok(arg);
						break;
				} // switch ( fmt )
			}).then(function(res){
				list[ res[0] ] = res[1];
			});
			proall.push(p);

			qdata.anim_fps++;
			i++;
		} // while ( i < len )

		return Promise.all(proall).then(function(res){
			var blob = new Blob(
				[ Q.binary.zipwrite(list) ],
				{ type : 'application/zip' }
			);
			var reader = new FileReader;
			reader.onload = function(){
				var fn = __.bak.fname + '.' + fmt + '.zip';
				__.download(fn, reader.result);
			};
			reader.readAsDataURL(blob);
		});
	}

	//////////////////////////////

	$.export = function( fmt, qdata, canvas, type, id, fps, zoom ){
		if ( zoom < 0.1 || zoom > 10.0 )
			return;

		Promise.resolve().then(function(r){
			__.backup(qdata, canvas, type, id, fps, zoom);
			switch ( fmt ){
				case 'png' :  return  __.export_sheet(qdata, canvas);
				case 'zip' :  return  __.export_zip(qdata, canvas, 'png');
				case 'rgba':  return  __.export_zip(qdata, canvas, 'rgba');
				default:      return 0;
			} // switch ( fmt )
		}).then(function(r){
			// performance
			//   png     69 ms     24,178 byte
			//   zip    121 ms     58,852 byte
			//   rgba  1470 ms  1,355,530 byte
			__.restore(qdata, canvas, fmt);
		});
	}

	//////////////////////////////

} // function QuadExport

	function BinaryReader(){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.uint2txt = function( buf ){
		buf = new Uint8Array(buf);
		return $.getstr(buf, 0, buf.byteLength);
	}

	$.cat_uint8 = function( a, b ){
		var c = new Uint8Array( a.byteLength + b.byteLength );
		c.set(a, 0);
		c.set(b, a.byteLength);
		return c;
	}

	//////////////////////////////

	$.getint = function( buf, pos, len ){
		var int = 0;
		for ( var i=0; i < len; i++ )
			int |= (buf[pos+i] << (i*8));
		return int;
	}

	$.getstr = function( buf, pos, len ){
		var str = '';
		for ( var i=0; i < len; i++ )
			str += String.fromCharCode( buf[pos+i] );
		return str;
	}

	$.getsub = function( buf, pos, len ){
		var sub = new Uint8Array(len);
		for ( var i=0; i < len; i++ )
			sub[i] = buf[pos+i];
		return sub;
	}

	$.zipread = function( zipbuf ){
		zipbuf = new Uint8Array(zipbuf)
		var list = {};
		var pos  = 0;
		while (1)
		{
			var mgc = $.getint(zipbuf, pos, 4);
			if ( mgc !== 0x04034b50 )  // PK34
				break;

			var sz1 = $.getint(zipbuf, pos + 0x12, 4); // data size
			var sz2 = $.getint(zipbuf, pos + 0x1a, 2); // filename length
			var sz3 = $.getint(zipbuf, pos + 0x1c, 2); // extra length

			// uncompressed file/store only
			if ( zipbuf[pos + 8] === 0 ){
				var fn = $.getstr(zipbuf, pos + 0x1e            , sz2);
				var dt = $.getsub(zipbuf, pos + 0x1e + sz2 + sz3, sz1);
				list[fn] = dt;
			}

			pos += (0x1e + sz1 + sz2 + sz3);
		} // while (1)
		return list;
	}

	//////////////////////////////

	$.setint = function( buf, pos, len, int ){
		for ( var i=0; i < len; i++ ){
			var b = int >> (i*8);
			buf[pos+i] = b & 0xff;
		}
	}

	$.setstr = function( buf, pos, str ){
		for ( var i=0; i < str.length; i++ )
			buf[pos+i] = str.charCodeAt(i);
	}

	$.setsub = function( buf, pos, sub ){
		for ( var i=0; i < sub.byteLength; i++ )
			buf[pos+i] = sub[i];
	}

	$.zipwrite = function( list ){
		var key = Object.keys(list);
		var pk34len = 0;
		var pk12len = 0;
		var pk56len = 0x16;

		var fnlen, dtlen, dtcrc;
		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			pk34len += (0x1e + fnlen + dtlen);
			pk12len += (0x2e + fnlen);
		} // for ( var i=0; i < key.length; i++ ){
		var zipbuf = new Uint8Array( pk34len + pk12len + pk56len );

		var pos34 = 0;
		var pos12 = pk34len;
		var pos56 = pk34len + pk12len;

		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			dtcrc = $.crc32( list[ key[i] ] );

			$.setint(zipbuf , pos12 , 4 , 0x02014b50);  // PK12
			zipbuf[ pos12 + 0x04 ] = 10;  // ver 1.0
			zipbuf[ pos12 + 0x06 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos12 + 0x10 , dtcrc);
			$.setint(zipbuf , pos12 + 0x14 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos12 + 0x18 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos12 + 0x1c , 2 , fnlen);
			$.setint(zipbuf , pos12 + 0x2a , 4 , pos34);
				pos12 += 0x2e;
			$.setstr(zipbuf , pos12 , key[i]);
				pos12 += fnlen;

			$.setint(zipbuf , pos34 , 4 , 0x04034b50);  // PK34
			zipbuf[ pos34 + 0x04 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos34 + 0x0e , dtcrc);
			$.setint(zipbuf , pos34 + 0x12 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos34 + 0x16 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos34 + 0x1a , 2 , fnlen);
				pos34 += 0x1e;
			$.setstr(zipbuf , pos34 , key[i]);
				pos34 += fnlen;
			$.setsub(zipbuf , pos34 , list[ key[i] ]);
				pos34 += dtlen;
		} // for ( var i=0; i < key.length; i++ ){

		$.setint(zipbuf , pos56 , 4, 0x06054b50);  // PK56
		$.setint(zipbuf , pos56 + 0x08 , 2, key.length);  // disk entry
		$.setint(zipbuf , pos56 + 0x0a , 2, key.length);  // total entry
		$.setint(zipbuf , pos56 + 0x0c , 4, pk12len);  // PK12 length
		$.setint(zipbuf , pos56 + 0x10 , 4, pk34len);  // PK12 pos
		return zipbuf;
	}

	//////////////////////////////

	$.crc32 = function( uint8 ){
		uint8 = new Uint8Array(uint8);
		var crc = new Uint16Array([255,255,255,255]);

		// https://stackoverflow.com/questions/21001659/crc32-algorithm-implementation-in-c-without-a-look-up-table-and-with-a-public-li
		// https://web.archive.org/web/20190108202303/http://www.hackersdelight.org/hdcodetxt/crc.c.txt
		// https://web.archive.org/web/20190716204559/http://www.hackersdelight.org/permissions.htm
		function shift(){
			var carry = 0;
			[3,2,1,0].forEach(function(e){
				crc[e] |= (carry << 8);
				carry = crc[e] & 1;
				crc[e] >>= 1;
			});
			return carry;
		}
		function xor( int ){
			var b;
			[0,1,2,3].forEach(function(e){
				b = (int >> (e*8)) & 0xff;
				crc[e] ^= b;
			});
		}

		var len = uint8.byteLength;
		for ( var i=0; i < len; i++ ){
			xor( uint8[i] );
			for ( var j=0; j < 8; j++ ){
				var mask = shift();
				if ( mask )
					xor( 0xedb88320 );
			}
		}
		xor( 0xffffffff );
		return new Uint8Array(crc);
	}

	//////////////////////////////

	// base64
	// 4 * 6-bit ASCII == 3 * 8-bit BINARY
	// in 24-bit sets

	$.to_base64 = function( uint8 ){
		//uint8 = new Uint8Array(uint8);
		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT6  = 0x3f;
		var len = uint8.byteLength;
		var pos = 0;

		var b, b1, b2, b3, b4;
		var b64 = '';
		while ( len >= 3 ){
			b = (uint8[pos+0] << 16) | (uint8[pos+1] << 8) | uint8[pos+2];
				pos += 3;
				len -= 3;

			b1 = (b >> 18) & BIT6;
			b2 = (b >> 12) & BIT6;
			b3 = (b >>  6) & BIT6;
			b4 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + token[b4];
		} // while ( len >= 3 ){

		if ( len === 2 ){
			b = (uint8[pos+0] << 8) | uint8[pos+1];
				b <<= 2

			b1 = (b >> 12) & BIT6;
			b2 = (b >>  6) & BIT6;
			b3 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + '=';
		}
		if ( len === 1 ){
			b = uint8[pos+0];
				b <<= 4;

			b1 = (b >>  6) & BIT6;
			b2 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + '==';
		}
		return b64;
	}

	$.from_base64 = function( b64 ){
		// data URL handling
		var st  = 0;
		var pos = b64.indexOf('base64,');
		if ( pos !== -1 )
			st = pos + 7;

		// must be length % 4 === 0
		var len = b64.length - st;
		if ( len < 1 || (len & 3) !== 0 )
			return '';

		// Uint8Array.reserve()
		var declen = (len >> 2) * 3;
		if ( b64[ b64.length - 1 ] === '=' ){
			declen--;
			if ( b64[ b64.length - 2 ] === '=' )
				declen--;
		}
		var uint8 = new Uint8Array(declen);

		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT8  = 0xff;

		var b, b1, b2, b3, b4;
		var dpos = 0;
		for ( var pos = st; pos < b64.length; pos += 4 ){
			b1 = token.indexOf( b64[pos+0] );
			b2 = token.indexOf( b64[pos+1] );

			if ( b64[pos+2] === '=' ){
				b = (b1 << 6) | b2;
					b >>= 4;
				uint8[dpos+0] = (b >> 0) & BIT8;
					dpos += 1;
				continue;
			}

			b3 = token.indexOf( b64[pos+2] );
			if ( b64[pos+3] === '=' ){
				b = (b1 << 12) | (b2 << 6) | b3;
					b >>= 2;
				uint8[dpos+0] = (b >> 8) & BIT8;
				uint8[dpos+1] = (b >> 0) & BIT8;
					dpos += 2;
				continue;
			}

			b4 = token.indexOf( b64[pos+3] );
			b = (b1 << 18) | (b2 << 12) | (b3 << 6) | b4;

			uint8[dpos+0] = (b >> 16) & BIT8;
			uint8[dpos+1] = (b >>  8) & BIT8;
			uint8[dpos+2] = (b >>  0) & BIT8;
				dpos += 3;
		} // for ( var pos=0; pos < b64.length; pos += 4 ){
		return uint8;
	}

	//////////////////////////////

} // function BinaryReader


	$.version = 'ver 2025-7-3 (beta)';
	$.gl   = new QuadGL  ($);
	$.func = new QuadFunc($);
	$.math = new QuadMath($);
	$.verify = new QuadVerify($);
	$.export = new QuadExport($);
	$.binary = new BinaryReader();

})(QUAD);

function QuadData(qlist){
	var $ = this;
	$.list = qlist;

	// uploaded files
	$.colorize = [];
	$.keyattr  = [];
	$.hitattr  = [];
	$.name = '';
	$.quad  = {};
	$.image = []; // { pos:rect , name:string }
	$.vram  = QUAD.gl.create_vram(255,255); // white solid texture

	// activated data
	$.is_wait  = true;
	$.is_draw  = false;
	$.is_hits  = true;
	$.is_lines = true;
	$.is_flipx = false;
	$.is_flipy = false;
	$.zoom   = 1;
	$.matrix = [1,0,0,0 , 0,1,0,0 , 0,0,1,0 , 0,0,0,1];
	$.color  = [1,1,1,1];

	$.attach = {
		type : '',
		id   : 0
	};
	$.anim_fps = 0;
	$.line_index = 0;
}
</script>
</head><body>

<main>
	<nav>
		<input type='file' id='input_file' multiple='multiple' class='hidden' />
		<button id='btn_upload' data-id='0'>upload</button>

		<button id='btn_lines'  >line</button>
		<button id='btn_zoomin' >+</button>
		<button id='btn_zoomout'>-</button>
	</nav>

	<div id='viewer'>
		<div id='viewer_xline'></div>
		<div id='viewer_yline'></div>
		<canvas id='canvas'>Canvas not supported</canvas>
	</div>

	<div id='debugger'>

		<div id='quad_data'>
			<h1 id='quad_version'>version</h1>
			<h2>Files</h2>
			<ol id='debugger_files'></ol>
			<ul id='keylist'></ul>
			<p>
				<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/debugger-keyframe.tpl.html' target='_blank'>Latest version</a> -
				<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/spec.html' target='_blank'>QUAD File Spec</a> -
				<a href='https://github.com/rufaswan/Web2D_Games' target='_blank'>Github</a>
			</p>
		</div>

		<div id='layerdata'>
			<div><button onclick='layer_close();'>close</button> <span id='layer_name'></span></div>

			<div>
				<select id='debuglist'></select>
				<button id='btn_selectall' class='hidden'>on</button>
				<button id='btn_selectnone' class='hidden'>off</button>
			</div>

			<ul id='layerlist'></ul>
		</div>

	</div>
</main>

<script>
'use strict';

APP.html         = APP.get_html_id();
APP.upload_queue = []; // { id:int , name:string , data:string }
APP.upload_id    = -1;
APP.autozoom     = 1.0;
APP.is_redraw    = true;
APP.camera       = QUAD.math.matrix4();
APP.color        = [1,1,1,1];
APP.QuadList     = [];

APP.on_key       = -1;
APP.on_layer     = [];

(function(){
	if ( ! QUAD.gl.init(APP.html.canvas) )
		return;

	document.title += ' - ' + QUAD.version;
	APP.html.quad_version.innerHTML = document.title;

	// BETWEEN DEBUGGER-VIEWER
	APP.html.btn_upload.addEventListener('click', function(){
		APP.upload_id = this.getAttribute('data-id');
		APP.html.input_file.click();
	});
	APP.html.input_file.addEventListener('change', function(){
		QUAD.func.log('QuadList[]', APP.upload_id);

		var proall = [];
		for ( var up of this.files ){
			var p = QUAD.func.upload_promise(up, APP.upload_id, APP.upload_queue);
			proall.push(p);
		}

		Promise.all(proall).then(function(res){
			return APP.process_uploads();
		});
	});

	// VIEWER
	APP.html.btn_zoomin.addEventListener('click', function(){
		APP.autozoom *= 1.1;
		if ( APP.autozoom > 10.0 )
			APP.autozoom = 10.0;
		APP.is_redraw = true;
	});
	APP.html.btn_zoomout.addEventListener('click', function(){
		APP.autozoom /= 1.1;
		if ( APP.autozoom < 0.1 )
			APP.autozoom = 0.1;
		APP.is_redraw = true;
	});
	APP.html.btn_lines.addEventListener('click', function(){
		if ( ! APP.QuadList[0] )
			return;
		var qdata = APP.QuadList[0];
		qdata.is_lines = ! qdata.is_lines;
		APP.html.btn_lines.innerHTML = ( qdata.is_lines ) ? 'line' : 'tex';
		APP.is_redraw = true;
	});
	APP.html.btn_selectall.addEventListener('click', function(){
		var dbg = APP.html.debuglist.value;
		if ( dbg.indexOf('#') < 0 )
			dbg = 0;
		APP.button_select_layers(dbg);
		APP.is_redraw = true;
	});
	APP.html.btn_selectnone.addEventListener('click', function(){
		var dbg = APP.html.debuglist.value;
		if ( dbg.indexOf('#') < 0 )
			dbg = 0;
		APP.button_unselect_layers(dbg);
		APP.is_redraw = true;
	});

	function render(){
		requestAnimationFrame(render);
		if ( ! APP.QuadList[0] || ! APP.QuadList[0].name )
			return;
		var qdata = APP.QuadList[0];

		// update/redraw only when changed
		if ( APP.is_redraw || QUAD.gl.is_canvas_resized() ){
			APP.camera = QUAD.func.viewer_camera(qdata, APP.autozoom);

			QUAD.func.qdata_clear(qdata);
			APP.keydebug_draw(qdata, APP.camera, APP.color);
			APP.is_redraw = false;
		}
	}
	render();
})();
</script>

</body></html>
