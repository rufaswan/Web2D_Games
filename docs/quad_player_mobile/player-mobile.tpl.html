<!doctype html>
<!--
Copyright (C) 2019 by Rufas Wan

This file is part of Web2D Games.
    <https://github.com/rufaswan/Web2D_Games>

Web2D Games is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Web2D Games is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with Web2D Games.  If not, see <http://www.gnu.org/licenses/>.
-->
<html><head>

<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<title>Quad Player - Mobile</title>
<style>:root {
	--body-bg-color     : #121212;
	--body-text-color   : #ededed;
	--button-bg-color   : #ededed;
	--button-text-color : #121212;
	--border-color      : #808080;
	--mobile-button-size-small   : 42px;

	--mobile-button-hspace-small : 18px;

	--mobile-button-vspace-small :  9px;
}
body {
	background-color : var(--body-bg-color);
}
body, a {
	color       : var(--body-text-color);
	font-family : sans-serif;
}

button {
	background-color : var(--button-bg-color);
	color            : var(--button-text-color);
	white-space      : nowrap;
	text-transform   : uppercase;
	margin           : var(--mobile-button-vspace-small)  var(--mobile-button-hspace-small);
	min-width        : var(--mobile-button-size-small);
	height           : var(--mobile-button-size-small);
	padding          : 0;
	border           : 1px var(--border-color) solid;
	box-sizing       : border-box;
}
button.btn_on {
	background-color : #0f0;
	color            : #000;
}

button.btn_off {
	background-color : #f00;
	color            : #fff;
}

textarea {
	display          : block;
	width            : 95%;
	height           : 25em;
	margin           : 0 auto 0;
	background-color : var(--body-text-color);
	color            : var(--body-bg-color);
	resize           : none;
}

h1, h2, h3, h4, h5, h6 {
	text-transform : uppercase;
	border-bottom  : 1px var(--border-color) solid;
}

ul {
	list-style-type : none;
}

.hidden {
	display : none;
}
.div_range {
	display        : flex;
	flex-direction : row;
	flex-wrap      : nowrap;
	padding        : 0.5em;
}
.div_range input {
	flex-grow : 2;
}

#viewer {
	position         : fixed;
	left             : 0;
	top              : 0;
	width            : 100vw;
	height           : 100vh;
	overflow         : auto;
	display          : none;
	background-color : var(--body-bg-color);
}

#viewer canvas,
#viewer_xline,
#viewer_yline {
	position : absolute;
	top      : 0;
	left     : 0;
}
#viewer_xline {
	width        :  50%;
	height       : 100%;
	border-right : 0.5em var(--border-color) solid;
}
#viewer_yline {
	width         : 100%;
	height        :  75%;
	border-bottom : 0.5em var(--border-color) solid;
}
#viewer canvas {
	width    : 100%;
	height   : 100%;
}

#viewer_top_nav,
#viewer_bottom_nav,
#debugger_top_nav {
	position : fixed;
	width    : 100vw;
	display  : block;
	margin   : 0;
	padding  : 0;
	display  : flex;
}
#debugger_top_nav {
	top              : 0;
	left             : 0;
	background-color : var(--body-bg-color);
	border-bottom    : 2px var(--border-color) solid;
	flex-direction   : row;
	flex-wrap        : nowrap;
	justify-content  : space-between;
	align-items      : center;
	align-content    : flex-start;
}
#debugger_top_dummy {
	display : block;
	height  : 60px;
}
#viewer_top_nav {
	top             : 0;
	left            : 0;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-between;
	align-items     : center;
	align-content   : flex-start;
	overflow        : scroll hidden;
}
#viewer_bottom_nav {
	bottom          : 0;
	left            : 0;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-between;
	align-items     : center;
	align-content   : flex-end;
}

#colorize_menu,
#keyattr_menu,
#hitattr_menu,
#export_menu {
	position         : fixed;
	bottom           : 0;
	background-color : var(--body-bg-color);
	display          : none;
	text-align       : center;
	border-top       : 2px var(--border-color) solid;
	padding-top      : 1em;
	width            : 100vw;
}

#export_menu button {
	margin : 1em;
}

#quad_data p {
	line-height     : var(--mobile-button-size-small);
	display         : flex;
	flex-direction  : row;
	flex-wrap       : nowrap;
	justify-content : space-around;
	align-items     : center;
}

#quad_data ul {
	padding : 0;
}
#quad_data ul ul {
	padding-left : var(--mobile-button-size-small);
}

#quad_data .liexpand,
#quad_data .liexport {
	background-color : var(--button-bg-color);
	color            : var(--button-text-color);
	white-space      : nowrap;
	text-transform   : uppercase;
	text-align       : center;
	min-height       : var(--mobile-button-size-small);
	padding          : 0.5em;
	border           : 1px var(--border-color) solid;
}

#quad_data .liname {
	flex-grow : 2;
	border    : 1px var(--border-color) solid;
	padding   : 0 0.5em;
}
#quad_data .current {
	background-color : var(--body-text-color);
	color            : var(--body-bg-color);
}

#quad_data_tags {
	padding-left : var(--mobile-button-size-small);
}
#quad_data_tags p {
	display      : block;
	padding-left : var(--mobile-button-size-small);
}
</style>
<script>'use strict';

var APP = {};

APP.get_html_id = function(){
	var html = {};
	var eles = document.querySelectorAll('*[id]');
	for ( var i=0; i < eles.length; i++ ) {
		var id   = eles[i].id;
		html[id] = eles[i];
	}
	return html;
}

APP.display_viewer = function( html, toggle ){
	if ( toggle )
		html.viewer.style.display = 'block';
	else
		html.viewer.style.display = 'none';
	html.export_menu.style.display = 'none';
}

APP.button_toggle = function( elem, turn ){
	if ( turn > 0 ){ // +1 = turn ON
		elem.classList.remove('btn_off');
		elem.classList.add('btn_on');
		return;
	}
	if ( turn < 0 ){ // -1 = turn OFF
		elem.classList.remove('btn_on');
		elem.classList.add('btn_off');
		return;
	}
	// 0 = not a ON/OFF button
	elem.classList.remove('btn_on');
	elem.classList.remove('btn_off');
}

APP.button_prev_next = function( qdata, adj ){
	adj = adj | 0;
	if ( ! qdata || adj === 0 )
		return;
	if ( ['keyframe','hitbox','slot'].indexOf(qdata.attach.type) !== -1 )
		qdata.attach.id += adj;
	else
		qdata.anim_fps  += adj;
}

APP.qdata_toggle = function( qdata, elem, key ){
	var t = elem.classList.contains('btn_on');
	if ( qdata )
		t |= qdata[key];

	if ( t ) // if ON, turn OFF
		APP.button_toggle(elem, -1);
	else // if OFF, turn ON
		APP.button_toggle(elem, 1);

	if ( qdata )
		qdata[key] = !t;
}

APP.qdata_filetable = function( qdata, files ){
	files.innerHTML = '';
	if ( qdata.name )
		files.innerHTML += '<li>[QUAD] ' + qdata.name + '</li>';
	for ( var i=0; i < qdata.image.length; i++ ){
		if ( ! qdata.image[i] || ! qdata.image[i].name )
			continue;
		var img = qdata.image[i];
		files.innerHTML += '<li>[IMAGE][' + i + '] ' + img.name + ' (' + JSON.stringify(img.pos) + ')</li>';
	}
}

APP.qdata_tagtable = function( tag ){
	if ( ! tag )
		return '';
	function wikilink( tagkey, tagval ){
		if ( tagkey.toLowerCase() === 'comment' || tagval === '-' )
			return tagval;
		var href = tagval.replace(/ /g, '_');
		return '<a href="https://en.m.wikipedia.org/wiki/' + href + '" target="_blank">' + tagval + '</a>';
	}

	var buffer = '<h2>tag</h2>';
	buffer += '<div id="quad_data_tags">';

	var keys = Object.keys(tag);
	keys.forEach(function(k){
		var t = {};
		t.l = k;
		if ( Array.isArray(tag[k]) ){
			t.v = [];
			tag[k].forEach(function(tv){
				t.v.push( wikilink( k, tv ) );
			});
			t.r = t.v.join(' , ');
		}
		else {
			t.r = wikilink( k, tag[k] );
		}

		buffer += '<h3>' + t.l + '</h3>';
		buffer += '<p>' + t.r + '</p>';
	});

	buffer += '</div>';
	return buffer;
}

APP.qdata_attach = function( qdata, type, id ){
	qdata.attach.type = type;
	qdata.attach.id   = id;
	qdata.anim_fps    = 0;
}

APP.quad_mainlist = function( quad ){
	var type = ['skeleton','animation','slot','keyframe','hitbox'];
	for ( var i=0; i < type.length; i++ ){
		var tv = type[i];
		if ( quad[tv].length > 0 )
			return tv;
	}
	return -1;
}

APP.qdata_listing = function( qdata, type, id ){
	if ( ! qdata.quad[type] || ! qdata.quad[type][id] )
		return '';
	var qchild = QUAD.export.list_attach(qdata, type, id);
	var qtype  = qdata.quad[type][id];

	var qname  = qtype.name || type + ' ' + id;
	if ( QUAD.export.is_loop_attach(qdata, type, id) )
		qname += ' <strong>[LOOP]</strong>';
	if ( QUAD.export.is_mix_attach(qdata, type, id) )
		qname += ' <strong>[MIX]</strong>';

	var html = '<li data-type="' + type + '" data-id="' + id + '"><p>';
	if ( qchild.length > 0 )
		html += '<span class="liexpand" onclick="button_expand(this);">+</span>';

	html += '<span class="liname" onclick="button_select(this);">' + qname + '</span>';

	if ( ['skeleton','animation'].indexOf(type) !== -1 )
		html += '<span class="liexport" onclick="button_export(this);">export</span>';
	html += '</p>';

	if ( qchild.length > 0 ){
		html += '<ul style="display:none;">';
		qchild.forEach(function(cv,ck){
			cv = cv.split(',');
			html += APP.qdata_listing(qdata, cv[0], cv[1]);
		});
		html += '</ul>';
	}

	html += '</li>';
	return html;
}

APP.viewer_btn_menu = function( qdata ){
	APP.html.btn_hitattr.style.display = 'none';
	APP.html.hitattr_list.innerHTML = '';
	if ( qdata.quad.hitbox.length > 0 )
		APP.html.btn_hitattr.style.display = 'block';

	APP.html.btn_keyattr.style.display = 'none';
	APP.html.keyattr_list.innerHTML = '';
	if ( qdata.quad.__ATTR.keyframe.length > 0 ){
		qdata.keyattr = -1;
		APP.html.btn_keyattr.style.display = 'block';
		var buffer = '';
		qdata.quad.__ATTR.keyframe.forEach(function(ev,ek){
			var mask = 1 << ek;
			buffer += '<button class="btn_on" onclick="qdata_attr(this,\'keyattr\',' + mask + ');">' + ev + '</button>';
		});
		APP.html.keyattr_list.innerHTML = buffer;
		QUAD.func.log('keyframe attr', qdata.quad.__ATTR.keyframe);
	}

	APP.html.btn_colorize.style.display = 'none';
	APP.html.colorize_list.innerHTML = '';
	if ( qdata.quad.__ATTR.colorize.length > 0 ){
		qdata.colorize = [];
		APP.html.btn_colorize.style.display = 'block';
		var buffer = '';
		qdata.quad.__ATTR.colorize.forEach(function(cv,ck){
			var mask = 1 << ck;
			qdata.colorize[mask] = [1,1,1,1];
			buffer += cv + ' = <input type="color" value="#ffffff" onchange="qdata_colorize(this,' + mask + ');">&nbsp;';
		});
		APP.html.colorize_list.innerHTML = buffer;
		QUAD.func.log('colorize attr', qdata.quad.__ATTR.colorize);
	}
}

//////////////////////////////
// function aaa()       + onclick='aaa();'
// APP.aaa = function() + var a = APP.aaa();

function div_range_span( elem ){
	// this = undefined
	var span = elem.parentElement.getElementsByTagName('span');
	span[0].innerHTML = elem.value;
}

function button_close( elem ){
	var par2 = elem.parentElement.parentElement;
	par2.style.display = 'none';
}

function button_select( elem ){
	if ( APP.selected )
		APP.selected.classList.remove('current');

	APP.selected = elem;
	APP.selected.classList.add('current');

	var par2 = elem.parentElement.parentElement;
	var type = par2.getAttribute('data-type');
	var id   = par2.getAttribute('data-id') | 0;

	APP.qdata_attach(APP.QuadList[0], type, id);
	APP.display_viewer(APP.html, true);
	APP.is_redraw = true;
}

function button_expand( elem ){
	var par2  = elem.parentElement.parentElement;
	var ulist = par2.getElementsByTagName('ul');
	if ( ulist.length < 1 )
		return;

	var dis = ulist[0].style.display;
	if ( dis === 'block' )
		ulist[0].style.display = 'none';
	else
		ulist[0].style.display = 'block';
}

function button_export( elem ){
	var par2 = elem.parentElement.parentElement;
	var type = par2.getAttribute('data-type');
	var id   = par2.getAttribute('data-id') | 0;

	var div = APP.html.export_menu;
	div.setAttribute('data-type', type);
	div.setAttribute('data-id'  , id);
	div.style.display = 'block';

	APP.html.export_name.innerHTML = type + ' , ' + id;

	var qdata = APP.QuadList[0];
	var time  = QUAD.export.time_attach(qdata, type, id);
	var range = APP.html.export_range;
	range.setAttribute('max', time - 1); // index 0
	range.value = 0;
}

function button_export_type( elem ){
	var fmt  = elem.innerHTML.toLowerCase();

	var div  = APP.html.export_menu;
	var type = div.getAttribute('data-type');
	var id   = div.getAttribute('data-id') | 0;

	var time = APP.html.export_range.value | 0;
	var zoom = APP.html.export_times.value * 1.0;
	QUAD.export.export(fmt, APP.QuadList[0], APP.html.canvas, type, id, time, zoom);
	APP.html.logger.innerHTML = QUAD.func.console();
}

function qdata_attr( elem, name, mask ){
	if ( elem.classList.contains('btn_on') ){
		APP.button_toggle(elem, -1);
		APP.QuadList[0][name] &= ~mask;
	}
	else {
		APP.button_toggle(elem, 1);
		APP.QuadList[0][name] |= mask;
	}
	APP.is_redraw = true;
}

function qdata_colorize( elem, id ){
	var color = elem.value;
	var div   = 1.0 / 255;
	var rgb   = [
		parseInt( color.substring(1,3) , 16 ) * div ,
		parseInt( color.substring(3,5) , 16 ) * div ,
		parseInt( color.substring(5,7) , 16 ) * div ,
		1.0,
	];
	APP.QuadList[0].colorize[id] = rgb;
	APP.is_redraw = true;
}
</script>
<script>'use strict';

var QUAD = {};

(function($){

	function QuadGL(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.GL = '';
	__.SHADER = {};
	__.MAX_TEX_SIZE = -1;

	$.init = function( dom ){
		var opt = {
			alpha                 : true,
			antialias             : true,
			depth                 : true,
			premultipliedAlpha    : false,
			preserveDrawingBuffer : true,
			stencil               : false,
		};
		__.GL = dom.getContext('webgl', opt);
		if ( ! __.GL )
			return Q.func.error('WebGL context failed');
		var form = __.GL.getShaderPrecisionFormat(__.GL.FRAGMENT_SHADER, __.GL.HIGH_FLOAT);
		if ( ! form )
			return Q.func.error('Fragment Shader has no highp support');

		var maxsz = $.detect_max_texsize();
		if ( maxsz < 1 )
			return Q.func.error('MAX_TEXTURE_SIZE < 1', maxsz);
		__.MAX_TEX_SIZE = maxsz | 0;
		var vec2_vram = 'vec2(' + maxsz.toFixed(1) + ' , ' + maxsz.toFixed(1) + ')';

		var vert_src, frag_src;
		Q.func.log('WebGL + highp init OK',
			['precision',form.precision],
			['MAX_TEXTURE_SIZE',__.MAX_TEX_SIZE]
		);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2  a_xy;
			uniform    highp  vec2  u_pxsize;

			highp  vec2  xy;
			void main(void){
				xy = a_xy * u_pxsize;
				gl_Position = vec4(xy.x, xy.y, 1.0 , 1.0);
			}
		`;
		frag_src = `
			uniform  highp  vec4  u_color;

			void main(void){
				gl_FragColor = u_color;
			}
		`;
		__.SHADER.lines = __.create_shader('draw lines', vert_src, frag_src);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec4   a_fog;
			attribute  highp  vec3   a_xyz;
			attribute  highp  vec2   a_uv;
			attribute  lowp   float  a_z;
			uniform    highp  vec2   u_pxsize;
			varying    highp  vec4   v_fog;
			varying    highp  vec2   v_uv;
			varying    highp  float  v_z;

			highp  vec4   fog;
			highp  vec2   xy;
			highp  vec2   uv;
			highp  float  z;
			void main(void){
				z = 1.0 / a_xyz.z;
				fog = a_fog    * z;
				xy  = a_xyz.xy * z * u_pxsize;
				uv  = a_uv     * z;

				v_fog = fog;
				v_uv  = uv;
				v_z   = z;
				gl_Position = vec4(xy.x, xy.y, a_z, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			varying  highp  vec4   v_fog;
			varying  highp  vec2   v_uv;
			varying  highp  float  v_z;

			highp  vec4   fog;
			highp  vec2   uv;
			highp  float  z;
			void main(void){
				z   = 1.0 / v_z;
				fog = v_fog * z;
				uv  = v_uv  * z;
				gl_FragColor = texture2D(u_tex, uv / ${vec2_vram}) * fog;
			}
		`;
		__.SHADER.keyframe = __.create_shader('draw keyframe', vert_src, frag_src);

		//////////////////////////////

		vert_src = `
			attribute  highp  vec2   a_xy;
			attribute  highp  vec2   a_uv;
			varying    highp  vec2   v_uv;

			highp  vec2  xy;
			void main(void){
				v_uv = a_uv;
				xy   = a_xy / ${vec2_vram};

				// convert 0.0 to 1.0 => -1.0 to +1.0
				xy = (xy * 2.0) - 1.0;
				gl_Position = vec4(xy.x, xy.y, 1.0, 1.0);
			}
		`;
		frag_src = `
			uniform  sampler2D  u_tex;
			uniform  highp  vec2   u_pxsize;
			varying  highp  vec2   v_uv;

			highp  vec2  uv;
			void main(void){
				uv = v_uv * u_pxsize;
				gl_FragColor = texture2D(u_tex, uv);
			}
		`;
		__.SHADER.vram = __.create_shader('draw vram', vert_src, frag_src);

		//////////////////////////////

		return true;
	}

	__.create_shader = function( name, vert_src, frag_src ){
		var vert_shader = __.GL.createShader(__.GL.VERTEX_SHADER);
		__.GL.shaderSource (vert_shader, vert_src);
		__.GL.compileShader(vert_shader);
		var t = __.GL.getShaderParameter(vert_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(vert_shader) );

		var frag_shader = __.GL.createShader(__.GL.FRAGMENT_SHADER);
		__.GL.shaderSource (frag_shader, frag_src);
		__.GL.compileShader(frag_shader);
		var t = __.GL.getShaderParameter(frag_shader, __.GL.COMPILE_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getShaderInfoLog(frag_shader) );

		var prog = __.GL.createProgram();
		__.GL.attachShader(prog, vert_shader);
		__.GL.attachShader(prog, frag_shader);
		__.GL.linkProgram (prog);
		var t = __.GL.getProgramParameter(prog, __.GL.LINK_STATUS);
		if ( ! t )
			return Q.func.error( __.GL.getProgramInfoLog(prog) );

		Q.func.log('shader init', name);
		return prog;
	}

	//////////////////////////////

	$.draw_line = function( quads, color ){
		__.GL.useProgram( __.SHADER.lines );
		var loc = __.shader_loc(__.SHADER.lines, 'a_xy', 'u_pxsize', 'u_color');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		__.GL.lineWidth(2);
		var pxsz = [ 1.0/view[0] , -1.0/view[1] ];

		__.set_vertex_attrib(loc.a_xy, quads, 2);
		__.GL.uniform4fv    (loc.u_color , color);
		__.GL.uniform2fv    (loc.u_pxsize, pxsz);
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var idxlen = quads.length / 2;  // number of x,y
		__.indice_line(idxlen);
	}

	$.draw_keyframe = function( dst, src, fog, z, image ){
		__.GL.useProgram( __.SHADER.keyframe );
		var loc = __.shader_loc(__.SHADER.keyframe, 'a_fog', 'a_xyz', 'a_uv', 'a_z', 'u_pxsize', 'u_tex');
		var view = [ __.GL.drawingBufferWidth * 0.5 , __.GL.drawingBufferHeight * 0.5 ];

		var pxsz = [ 1.0/view[0] , -1.0/view[1] ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, image.tex);

		__.set_vertex_attrib(loc.a_xyz, dst, 3);
		__.set_vertex_attrib(loc.a_uv , src, 2);
		__.set_vertex_attrib(loc.a_fog, fog, 4);
		__.set_vertex_attrib(loc.a_z  , z  , 1);
		__.GL.uniform2f     (loc.u_pxsize, pxsz[0], pxsz[1]);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, view[0]*2, view[1]*2);

		var dstlen = dst.length / 3; // number of x,y
		__.indice_quad(dstlen);
	}

	$.draw_vram = function( vram, tex, rect ){
		__.GL.useProgram( __.SHADER.vram );
		var loc = __.shader_loc(__.SHADER.vram, 'a_xy', 'a_uv', 'u_pxsize', 'u_tex');
		var sw = rect[2] - rect[0];
		var sh = rect[3] - rect[1];

		// to be used with canvas - DO NOT flipy !
		var pxsz = [ 1.0/sw , 1.0/sh ];
		__.GL.activeTexture(__.GL.TEXTURE0);
		__.GL.bindTexture  (__.GL.TEXTURE_2D, tex);

		var dst = [
			rect[0] , rect[1] ,
			rect[2] , rect[1] ,
			rect[2] , rect[3] ,
			rect[0] , rect[3] ,
		];
		var src = [0,0 , sw,0 , sw,sh , 0,sh];
		__.set_vertex_attrib(loc.a_xy, dst, 2);
		__.set_vertex_attrib(loc.a_uv, src, 2);
		__.GL.uniform2f     (loc.u_pxsize, pxsz[0], pxsz[1]);
		__.GL.uniform1i     (loc.u_tex   , 0   );
		__.GL.viewport(0, 0, vram.w, vram.h);

		$.enable_framebuffer(vram.tex);
		__.indice_quad(4);
		$.enable_framebuffer(0);
	}

	__.indice_line = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1 , i+1,i+2 , i+2,i+3 , i+3,i+0);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y   = 8 numbers
		//        = 4 lines = 8 points / indices
		__.GL.drawElements(__.GL.LINES, len/4*8, __.GL.UNSIGNED_SHORT, 0);
	}

	__.indice_quad = function( len ){
		var idx = [];
		for ( var i=0; i < len; i += 4 )
			idx.push(i+0,i+1,i+2 , i+0,i+2,i+3);

		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ELEMENT_ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(idx), __.GL.STATIC_DRAW);

		// 1 quad = 4 x,y       =  8 numbers
		//        = 4 x,y,z     = 12 numbers
		//        = 2 triangles =  6 points / indices
		__.GL.drawElements(__.GL.TRIANGLES, len/4*6, __.GL.UNSIGNED_SHORT, 0);
	}

	__.shader_loc = function(){
		var shader = arguments[0];
		var loc    = {};
		for ( var i=1; i < arguments.length; i++ )
		{
			var v = arguments[i];
			switch ( v.charAt(0) ){
			case 'a':  loc[v] = __.GL.getAttribLocation (shader, v); break;
			case 'u':  loc[v] = __.GL.getUniformLocation(shader, v); break;
			}
		} // for ( var i=1; i < arguments.length; i++ )
		return loc;
	}

	__.set_vertex_attrib = function( loc, data, v ){
		var buf = __.GL.createBuffer();
		__.GL.bindBuffer(__.GL.ARRAY_BUFFER, buf);
		__.GL.bufferData(__.GL.ARRAY_BUFFER, new Float32Array(data), __.GL.STATIC_DRAW);
		__.GL.enableVertexAttribArray(loc);
		__.GL.vertexAttribPointer(loc, v, __.GL.FLOAT, false, 0, 0);
	}

	//////////////////////////////

	$.create_texture = function(){
		var tex = __.GL.createTexture();
		__.GL.bindTexture  (__.GL.TEXTURE_2D, tex);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_S    , __.GL.CLAMP_TO_EDGE);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_WRAP_T    , __.GL.CLAMP_TO_EDGE);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MIN_FILTER, __.GL.NEAREST);
		__.GL.texParameteri(__.GL.TEXTURE_2D, __.GL.TEXTURE_MAG_FILTER, __.GL.NEAREST);
		return tex;
	}

	$.update_texture = function( tex, img ){
		if ( ! tex )
			tex = $.create_texture();
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level , internalformat
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
		img);
	}

	$.create_pixel = function( hex, w=1, h=1 ){
		hex = Q.math.clamp(hex, 0, 255) | 0;
		if ( w < 0 )  w = __.MAX_TEX_SIZE;
		if ( h < 0 )  h = __.MAX_TEX_SIZE;

		var size  = w * h * 4;
		var uint8 = new Uint8Array(size);
		for ( var i=0; i < size; i++ )
			uint8[i] = hex;

		var pix = {
			w : w ,
			h : h ,
			tex : $.create_texture() ,
		};
		__.GL.bindTexture(__.GL.TEXTURE_2D, pix.tex);
		__.GL.texImage2D(
			__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
			pix.w , pix.h    , 0                   , // width  , height , border
			__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
			uint8
		);
		return pix;
	}

	$.to_uint8 = function(){
		return new Promise(function(ok,err){
			__.GL.canvas.toBlob(function(blob){
				var reader = new FileReader;
				reader.onload = function(){
					var uint8 = new Uint8Array(reader.result);
					ok(uint8);
				};
				reader.readAsArrayBuffer(blob);
			}, 'image/png');
		});
	}

	$.read_RGBA = function(){
		var bw = __.GL.drawingBufferWidth;
		var bh = __.GL.drawingBufferHeight;
		var buf = new Uint8Array( bw * bh * 4 );
		__.GL.readPixels(0, 0, bw, bh, __.GL.RGBA, __.GL.UNSIGNED_BYTE, buf);

		var pix = new Uint8Array( 12 + (bw * bh * 4) );
		Q.binary.setint(pix, 0, 4, 0x41424752); // RGBA
		Q.binary.setint(pix, 4, 4, bw);
		Q.binary.setint(pix, 8, 4, bh);

		// vflip the image
		var row = bw * 4;
		for ( var dy=0; dy < bh; dy++ ){
			var dyy = 12 + (dy * row);
			var syy = (bh - 1 - dy) * row;

			for ( var x=0; x < row; x++ ){
				pix[dyy] = buf[syy];
				dyy++;
				syy++;
			}
		} // for ( var dy=0; dy < bh; dy++ )
		return pix;
	}

	//////////////////////////////

	$.enable_blend = function( blend ){
		if ( ! blend )
			return __.GL.disable(__.GL.BLEND);

		var c = blend.color;
		__.GL.blendColor(c[0], c[1], c[2], c[3]);

		if ( ! blend.mode_alpha )
			blend.mode_alpha = blend.mode_rgb;

		var mc = blend.mode_rgb;
		var ma = blend.mode_alpha;
		__.GL.blendEquationSeparate(__.GL[ mc[0] ] , __.GL[ ma[0] ]);
		__.GL.blendFuncSeparate    (__.GL[ mc[1] ] , __.GL[ mc[2] ] , __.GL[ ma[1] ] , __.GL[ ma[2] ]);
		return __.GL.enable(__.GL.BLEND);
	}

	$.enable_depth = function( depth ){
		if ( ! depth ){
			__.GL.clear(__.GL.DEPTH_BUFFER_BIT);
			//__.GL.depthMask(true); // can write depth
			__.GL.clearDepth(1.0);
			return __.GL.disable(__.GL.DEPTH_TEST);
		}

		__.GL.depthFunc(__.GL[depth]);
		return __.GL.enable(__.GL.DEPTH_TEST);
	}

	$.enable_framebuffer = function( tex ){
		if ( ! tex ){
			__.GL.bindFramebuffer(__.GL.FRAMEBUFFER, null);
			return null;
		}

		var fb = __.GL.createFramebuffer();
		__.GL.bindFramebuffer     (__.GL.FRAMEBUFFER, fb);
		__.GL.framebufferTexture2D(__.GL.FRAMEBUFFER, __.GL.COLOR_ATTACHMENT0, __.GL.TEXTURE_2D, tex, 0);
		var t = __.GL.checkFramebufferStatus(__.GL.FRAMEBUFFER);
		if ( t === __.GL.FRAMEBUFFER_COMPLETE ){
			Q.func.log('framebuffer OK');
			return fb;
		}
		return Q.func.error('framebuffer failed',t);
	}

	$.clear = function(){
		__.GL.clear(__.GL.COLOR_BUFFER_BIT);
		//__.GL.colorMask(true , true , true , true); // can write red, green, blue, alpha
		__.GL.clearColor(0 , 0 , 0 , 0);
		__.GL.flush();
	}

	$.is_gl_enum = function( str ){
		if ( Array.isArray(str) ){
			for ( var i=0; i < str.length; i++ ){
				str[i] = str[i].toUpperCase();
				if ( ! __.GL[ str[i] ] )
					return false;
			}
			return true;
		}
		return false;
	}

	//////////////////////////////

	$.drawingbuffer_size = function( max ){
		return [ __.GL.drawingBufferWidth , __.GL.drawingBufferHeight ];
	}

	$.detect_max_texsize = function(){
		var tex = $.create_texture();
		__.GL.bindTexture(__.GL.TEXTURE_2D, tex);

		var maxsz = __.GL.getParameter( __.GL.MAX_TEXTURE_SIZE ) >> 1;
		var bw = __.GL.canvas.width;
		var bh = __.GL.canvas.height;

		if ( maxsz < 0 )
			maxsz = 0;
		while ( maxsz > 0 ){
			// test if reading texture at this size
			__.GL.texImage2D(
				__.GL.TEXTURE_2D , 0 , __.GL.RGBA      , // target , level  , internalformat
				maxsz , maxsz    , 0                   , // width  , height , border
				__.GL.RGBA       , __.GL.UNSIGNED_BYTE , // format , type
				null
			);
			// test if writing canvas at this size
			__.GL.canvas.width  = maxsz;
			__.GL.canvas.height = maxsz;

			var error = 0;
			error |= ( __.GL.getError()    !== __.GL.NO_ERROR            );
			error |= ( __.GL.canvas.width  >   __.GL.drawingBufferWidth  );
			error |= ( __.GL.canvas.height >   __.GL.drawingBufferHeight );
			if ( error === 0 )
				break;

			// has error, halved maxsz and test again
			maxsz >>= 1;
		} // while ( maxsz > 0 )

		// restore canvas size after testing
		__.GL.canvas.width  = bw;
		__.GL.canvas.height = bh;
		return maxsz;
	}

	$.max_texsize = function(){
		return __.MAX_TEX_SIZE;
	}
	$.is_max_texsize = function(w, h){
		if ( w > __.MAX_TEX_SIZE || h > __.MAX_TEX_SIZE )
			return false;
		return true;
	}

	$.canvas_size = function(){
		return [ __.GL.canvas.width * 0.5 , __.GL.canvas.height * 0.5 ];
	}

	$.is_canvas_resized = function(){
		// display.block = [w,h] , display.none = [0,0]
		var c = 0;
		c |= ( __.GL.canvas.width  !== __.GL.canvas.clientWidth  );
		c |= ( __.GL.canvas.height !== __.GL.canvas.clientHeight );

		if ( c ){
			__.GL.canvas.width  = __.GL.canvas.clientWidth;
			__.GL.canvas.height = __.GL.canvas.clientHeight;
		}
		return c;
	}

	//////////////////////////////

} // function QuadGL

	function QuadFunc(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.LOGS = [];
	$.log = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return true;
	}
	$.error = function(){
		var arg = [].slice.call(arguments);
		var txt = JSON.stringify(arg);
		__.LOGS.unshift( 'ERROR : ' + txt );
		while ( __.LOGS.length > 20 )
			__.LOGS.pop();
		return false;
	}
	$.console = function(){
		return __.LOGS.join("\n\n");
	}

	$.is_array = function( array, size ){
		if ( ! Array.isArray(array) )
			return false;
		if ( array.length !== size )
			return false;
		return true;
	}
	$.is_array_unique = function( array ){
		if ( ! Array.isArray(array) )
			return false;
		for ( var i=0; i < array.length; i++){
			var idx = array.indexOf( array[i] );
			if ( idx !== i )
				return false;
		}
		return true;
	}
	$.array_clean_null = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list[len] === 0 )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_clean_dups = function( list ){
		if ( ! Array.isArray(list) )
			return;
		var len = list.length;
		while ( len > 0 ){
			len--;
			if ( list.indexOf( list[len] ) !== len )
				list.splice(len, 1);
		} // while ( len > 0 )
	}
	$.array_number = function( size ){
		var array = [];
		for ( var i=0; i < size; i++ )
			array.push(i);
		return array;
	}

	$.is_undef = function( a ){
		return ( typeof a === 'undefined' );
	}
	$.file_extension = function( fn ){
		var ext = fn.split('.').pop();
		return ext.toLowerCase();
	}
	$.copy_object = function( obj ){
		return JSON.parse( JSON.stringify(obj) );
	}
	$.attr_bitflag = function( attrib, enumlist ){
		if ( Array.isArray(attrib) ){
			var bitflag = 0;
			for ( var i=0; i < attrib.length; i++ )
				bitflag |= $.attr_bitflag(attrib[i], enumlist);
			return bitflag;
		}
		if ( typeof attrib === 'string' ){
			var idx = enumlist.indexOf(attrib);
			if ( idx < 0 ){
				idx = enumlist.length;
				enumlist.push(attrib);
			}
			return (1 << idx);
		}
		return 0;
	}

	//////////////////////////////

	$.upload_promise = function( up, qdata ){
		var ext = $.file_extension(up.name);
		switch ( ext ){
			case 'zip':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						var list = Q.binary.zipread( reader.result );
						ok(list);
					}
					reader.readAsArrayBuffer(up);
				}).then(function(list){
					var key = Object.keys(list);
					var proall = [];
					for ( var i=0; i < key.length; i++ ){
						var ext = $.file_extension( key[i] );

						switch ( ext ){
							case 'quad':
								var p = new Promise(function(ok,err){
									var fn   = key[i];
									var blob = new Blob(
										[ list[fn] ],
										{ type : 'text/plain' }
									);
									var reader = new FileReader;
									reader.onload = function(){
										ok([fn,reader.result]);
									}
									reader.readAsText(blob);
								}).then(function(res){
									return __.upload_handler(qdata, 'quad', res[0], res[1]);
								});
								proall.push(p);
								break;
							case 'png':
								var p = new Promise(function(ok,err){
									var fn   = key[i];
									var blob = new Blob(
										[ list[fn] ],
										{ type : 'image/png' }
									);
									var reader = new FileReader;
									reader.onload = function(){
										ok([fn,reader.result]);
									}
									reader.readAsDataURL(blob);
								}).then(function(res){
									return __.upload_handler(qdata, 'image', res[0], res[1]);
								});
								proall.push(p);
								break;
						} // switch ( ext )
					} // for ( var i=0; i < key.length; i++ )
					return Promise.all(proall);
				});

			case 'quad':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						ok(reader.result);
					}
					reader.readAsText(up);
				}).then(function(text){
					return __.upload_handler(qdata, 'quad', up.name, text);
				});

			case 'png':
				return new Promise(function(ok,err){
					var reader = new FileReader;
					reader.onload = function(){
						ok(reader.result);
					}
					reader.readAsDataURL(up);
				}).then(function(data){
					return __.upload_handler(qdata, 'image', up.name, data);
				});
		} // switch ( ext )
		return 0;
	}

	__.is_rect_collide = function( rect, list ){
		function collide( rect1, rect2 ){
			if ( rect1[0] >= rect2[2] )  return false; // r1.x1 >= r2.x2 , over right
			if ( rect1[1] >= rect2[3] )  return false; // r1.y1 >= r2.y2 , over bottom
			if ( rect1[2] <= rect2[0] )  return false; // r1.x2 <= r2.x1 , over left
			if ( rect1[3] <= rect2[1] )  return false; // r1.y2 <= r2.y1 , over top
			return true;
		}
		for ( var i=0; i < list.length; i++ ){
			if ( ! list[i] )
				continue;
			var col = collide(rect, list[i].pos);
			if ( col )
				return true;
		}
		return false;
	}

	__.vram_posrect = function( vram, texsz, list ){
		for ( var y=0; y < vram.h; y += 0x80 ){
			var y2 = y + texsz[1];
			if ( y2 > vram.h )
				continue;

			for ( var x=0; x < vram.w; x += 0x80 ){
				if ( x === 0 && y === 0 ) // reserve white pixel for fog
					continue;
				var x2 = x + texsz[0];
				if ( x2 > vram.w )
					continue;

				var rect = [x , y , x2 , y2];
				var col = __.is_rect_collide(rect, list);
				if ( ! col )
					return rect;
			} // for ( var x = 0x80; x < vram.w; x += 0x80 )
		} // for ( var y = 0x80; y < vram.h; y += 0x80 )

		// failed to allocate VRAM
		return 0;
	}

	__.upload_handler = function( qdata, type, fname, data ){
		switch( type ){
			case 'quad':
				var quad   = JSON.parse(data);
				qdata.quad = __.quadfile_check(quad);
				qdata.name = fname.replace(/[^A-Za-z0-9]/g, '_');
				return $.log('UPLOAD quad', fname);

			case 'image':
				return new Promise(function(ok,err){
					var dummytex = Q.gl.create_pixel(255);
					var fnm = fname.match(/\.([0-9]+)\./);
					var tid = fnm[1];

					var img = new Image;
					img.onload = function(){
						ok([tid,img]);
					}
					img.src = data;
				}).then(function(res){
					var tid = res[0];
					var img = res[1];

					var tex = Q.gl.create_texture();
					Q.gl.update_texture(tex, img);
					return [tid,tex,img.width,img.height];
				}).then(function(res){
					var tid = res[0];
					var tex = res[1];
					var w = res[2];
					var h = res[3];

					// remove loaded texture
					qdata.image[tid] = 0;
					var pos = __.vram_posrect( qdata.vram , [w,h] , qdata.image );
					if ( ! pos )
						return $.error('cannot fit texture into VRAM', [qdata.vram.w,qdata.vram.h] , [w,h] , qdata.image);

					Q.gl.enable_blend(0);
					Q.gl.draw_vram(qdata.vram, tex, pos);
					qdata.image[tid] = {
						pos  : pos,
						name : fname,
					};
					return $.log('UPLOAD image', tid, qdata.image[tid]);
				});
		} // switch( type )
		return 0;
	}

	__.key_fogquad = function( fog ){
		if ( typeof fog === 'string' ){
			var c = Q.math.css_color(fog);
			return [].concat(c, c, c, c);
		}
		if ( $.is_array(fog, 4) ){
			var c0 = Q.math.css_color( fog[0] );
			var c1 = Q.math.css_color( fog[1] );
			var c2 = Q.math.css_color( fog[2] );
			var c3 = Q.math.css_color( fog[3] );
			return [].concat(c0, c1, c2, c3);
		}
		// default solid white
		return [1,1,1,1 , 1,1,1,1 , 1,1,1,1 , 1,1,1,1];
	}

	__.quadfile_check = function( quad ){
		quad.blend     = quad.blend     || [];
		quad.slot      = quad.slot      || [];
		quad.hitbox    = quad.hitbox    || [];
		quad.keyframe  = quad.keyframe  || [];
		quad.animation = quad.animation || [];
		quad.skeleton  = quad.skeleton  || [];
		quad.__MIX     = [];
		quad.__ATTR    = {
			keyframe : [],
			hitbox   : [],
			colorize : [],
		};

		var ent;
		function nullent(arr,k){
			arr[k] = 0;
		}

		quad.blend.forEach(function(bv,bk){
			if ( ! Q.gl.is_gl_enum(bv.mode_rgb) )
				bv.mode_rgb = 0;
			if ( ! $.is_array(bv.mode_rgb, 3) )
				return nullent(quad.blend, bk);
			ent = {
				'mode_rgb'   : bv.mode_rgb,
				'mode_alpha' : 0,
				'name'       : bv.name || 'blend ' + bk,
				'color'      : Q.math.css_color( bv.color ),
			};
			if ( ! Q.gl.is_gl_enum(bv.mode_alpha) )
				bv.mode_alpha = 0;
			if ( $.is_array(bv.mode_alpha, 3) )
				ent.mode_alpha = bv.mode_alpha;
			quad.blend[bk] = ent;
		}); // quad.blend.forEach

		quad.hitbox.forEach(function(hv,hk){
			if ( ! Array.isArray(hv.layer) )
				return nullent(quad.hitbox, hk);
			var is_null = true;
			hv.layer.forEach(function(lv,lk){
				if ( ! $.is_array(lv.hitquad, 8) )
					return nullent(hv.layer, lk);
				is_null = false;
				hv.layer[lk] = {
					'debug'     : JSON.stringify(lv.debug || 0),
					'hitquad'   : lv.hitquad,
					'attribute' : $.attr_bitflag( lv.attribute, quad.__ATTR.hitbox ),
				};
			}); // hv.layer.forEach
			if ( is_null )
				return nullent(quad.hitbox, hk);
			ent = {
				'debug' : JSON.stringify(hv.debug || 0),
				'name'  : hv.name  || 'hitbox '+ hk,
				'layer' : hv.layer,
			};
			quad.hitbox[hk] = ent;
		}); // quad.hitbox.forEach

		quad.keyframe.forEach(function(kv,kk){
			if ( ! Array.isArray(kv.layer) )
				return nullent(quad.keyframe, kk);
			var is_null = true;
			kv.layer.forEach(function(lv,lk){
				if ( ! $.is_array(lv.dstquad, 8) )
					return nullent(kv.layer, lk);
				is_null = false;
				ent = {
					'debug'     : JSON.stringify(lv.debug || 0),
					'dstquad'   : lv.dstquad,
					'blend_id'  : -1,
					'fogquad'   : __.key_fogquad( lv.fogquad ),
					'attribute' : $.attr_bitflag( lv.attribute, quad.__ATTR.keyframe ),
					'colorize'  : $.attr_bitflag( lv.colorize , quad.__ATTR.colorize ),
					'tex_id'    : -1,
					'srcquad'   : 0,
				};
				if ( ! $.is_undef(lv.blend_id)   )  ent.blend_id = lv.blend_id | 0; // 0 is valid
				if ( ! $.is_undef(lv.tex_id  )   )  ent.tex_id   = lv.tex_id   | 0; // 0 is valid
				if ( ent.blend_id < 0 )  ent.blend_id = -1;
				if ( ent.tex_id   < 0 )  ent.tex_id   = -1;
				if (   $.is_array(lv.srcquad, 8) )  ent.srcquad  = lv.srcquad;
				kv.layer[lk] = ent;
			}); // kv.layer.forEach
			if ( is_null )
				return nullent(quad.keyframe, kk);
			ent = {
				'debug'  : JSON.stringify(kv.debug || 0),
				'name'   : kv.name  || 'keyframe '+ kk,
				'layer'  : kv.layer,
				'order'  : kv.order,
				'__RECT' : 0,
			};
			if ( ! $.is_array_unique(ent.order) )
				ent.order = $.array_number( kv.layer.length );
			quad.keyframe[kk] = ent;
		}); // quad.keyframe.forEach

		quad.animation.forEach(function(av,ak){
			if ( ! Array.isArray(av.timeline) )
				return nullent(quad.animation, ak);
			av.timeline.forEach(function(tv,tk){
				if ( tv.time < 1 )
					return nullent(av.timeline, tk);
				ent = {
					'debug'        : JSON.stringify(tv.debug  || 0),
					'time'         : tv.time,
					'attach'       : tv.attach || 0 ,
					'matrix'       : 0,
					'color'        : Q.math.css_color(tv.color),
					'matrix_mix'   : ( tv.matrix_mix   ) ? true : false,
					'color_mix'    : ( tv.color_mix    ) ? true : false,
					'keyframe_mix' : ( tv.keyframe_mix ) ? true : false,
					'hitbox_mix'   : ( tv.hitbox_mix   ) ? true : false,
				};
				if ( $.is_array(tv.matrix, 16) )
					ent.matrix = tv.matrix;
				av.timeline[tk] = ent;
			}); // av.timeline.forEach
			$.array_clean_null(av.timeline);
			if ( av.timeline.length < 1 )
				return nullent(quad.animation, ak);
			ent = {
				'debug'    : JSON.stringify(av.debug || 0),
				'name'     : av.name  || 'animation' + ak,
				'timeline' : av.timeline,
				'loop_id'  : -1,
				'__RECT'   : 0,
			};
			if ( ! $.is_undef(av.loop_id) )  ent.loop_id = av.loop_id | 0; // 0 is valid
			quad.animation[ak] = ent;
		}); // quad.animation.forEach

		quad.skeleton.forEach(function(sv,sk){
			if ( ! Array.isArray(sv.bone) || sv.bone.length < 1 )
				return nullent(quad.skeleton, sk);
			sv.bone.forEach(function(bv,bk){
				ent = {
					'debug'     : JSON.stringify(bv.debug  || 0),
					'name'      : bv.name   || 'bone ' + bk,
					'attach'    : bv.attach || 0,
				};
				sv.bone[bk] = ent;
			}); // sv.bone.forEach
			quad.skeleton[sk] = {
				'debug'  : JSON.stringify(sv.debug || 0),
				'name'   : sv.name  || 'skeleton ' + sk,
				'bone'   : sv.bone,
				'__RECT' : 0,
			};
		}); // quad.skeleton.forEach

		return quad;
	}

	//////////////////////////////

	__.draw_lines = function( qdata, layer, mat4, quad ){
		var clines = [];

		var debug = [];
		layer.forEach(function(lv,lk){
			if ( ! lv )
				return;

			var dbg_id = debug.indexOf(lv.debug);
			if ( dbg_id < 0 ){
				dbg_id = debug.length;
				debug.push(lv.debug);
				clines[dbg_id] = [];
			}

			var dst = Q.math.quad_multi4(mat4, lv[quad]);
			clines[dbg_id] = clines[dbg_id].concat(dst);
		});

		var color = [
			[1,0,0,1] , [0,1,0,1] , [0,0,1,1] , // rgb
			[0,1,1,1] , [1,0,1,1] , [1,1,0,1] , // cmy
			[0,0,0,1] , [1,1,1,1] ,             // black white
			[0.5,0  ,0  ,1] , [0  ,0.5,0  ,1] , [0  ,0  ,0.5,1] , // 0.5 rgb
			[0  ,0.5,0.5,1] , [0.5,0  ,0.5,1] , [0.5,0.5,0  ,1] , // 0.5 cmy
			[0.5,0.5,0.5,1] , // gray
		];

		Q.gl.enable_blend(0);
		clines.forEach(function(cv,ck){
			var cid = qdata.line_index % color.length;
			Q.gl.draw_line(cv, color[cid]);

			qdata.line_index++;
			qdata.is_draw = true;
		});
	}

	__.draw_hitbox = function( qdata, hid, mat4 ){
		var layer = qdata.quad.hitbox[hid].layer;
		__.draw_lines(qdata, layer, mat4, 'hitquad');
	}

	//////////////////////////////

	__.draw_keyframe_tex = function( qdata, layer, order, mat4, color ){
		var dummysrc = [0,0 , 0,0 , 0,0 , 0,0];

		var zrate = 1.0 / (layer.length + 1);
		var buf_list = {};
		var depth = 1.0;
		//console.log('order',order);

		// draw layers by keyframe order
		order.forEach(function(ov){
			var lv = layer[ov];
			if ( ! lv )
				return;
			if ( (qdata.keyattr & lv.attribute) !== lv.attribute )
				return;
			depth -= zrate;

			var bid = lv.blend_id | 0;
			if ( ! buf_list[bid] )
				buf_list[bid] = { dst:[] , src:[] , fog:[] , z:[] };
			var ent = buf_list[bid];

			if ( lv.tex_id < 0 || ! qdata.image[lv.tex_id] || ! lv.srcquad )
				var src = dummysrc;
			else
				var src = Q.math.vram_srcquad(lv.srcquad, qdata.image[lv.tex_id].pos);
			ent.src = ent.src.concat(src);

			var dst = Q.math.quad_multi4(mat4, lv.dstquad);
			var xyz = Q.math.perspective_quad(dst);
			ent.dst = ent.dst.concat(xyz);

			if ( lv.colorize > 0 ){
				var clr = qdata.colorize[lv.colorize];
				clr = Q.math.vec4_multi(clr, color);
				clr = Q.math.fog_multi4(clr, lv.fogquad);
			}
			else
				var clr = Q.math.fog_multi4(color, lv.fogquad);
			ent.fog = ent.fog.concat(clr);

			ent.z = ent.z.concat([depth , depth , depth , depth]);
		});
		//console.log('buf_list',buf_list);

		Q.gl.enable_depth('LESS');
		for ( var i = -1; i < qdata.quad.blend.length; i++ ){
			if ( ! buf_list[i] ) // no data to draw
				continue;

			if ( i < 0 ) // disable blending
				Q.gl.enable_blend(0);
			else {
				if ( ! qdata.quad.blend[i] ) // invalid or unknown blending
					continue;
				Q.gl.enable_blend( qdata.quad.blend[i] );
			}

			qdata.is_draw = true;
			var bv = buf_list[i];
			Q.gl.draw_keyframe( bv.dst, bv.src, bv.fog, bv.z, qdata.vram );
		} // for ( var i = -1; i < qdata.quad.blend.length; i++ )
		Q.gl.enable_depth(0);
	}

	__.draw_keyframe = function( qdata, kid, mat4, color ){
		var key = qdata.quad.keyframe[kid];
		if ( qdata.is_lines )
			return __.draw_lines(qdata, key.layer, mat4, 'dstquad');
		else
			return __.draw_keyframe_tex(qdata, key.layer, key.order, mat4, color);
	}

	//////////////////////////////

	__.draw_MIX = function( qdata, id, mat4, color ){
		var mix = qdata.quad.__MIX[id];
		if ( mix.keyframe ){
			if ( qdata.is_lines )
				__.draw_lines(qdata, mix.keyframe.layer, mat4, 'dstquad');
			else
				__.draw_keyframe_tex(qdata, mix.keyframe.layer, mix.keyframe.order, mat4, color);
		}
		if ( mix.hitbox && qdata.is_hits )
			__.draw_lines(qdata, mix.hitbox.layer, mat4, 'hitquad');
	}

	__.mix_attach = function( qdata, cur, nxt, rate, keymix, hitmix ){
		function getmixed( mixed, attach ){
			switch ( attach.type ){
				case 'slot':
					if ( ! qdata.quad.slot[ attach.id ] )
						return;
					qdata.quad.slot[ attach.id ].forEach(function(sv,sk){
						getmixed(mixed, sv);
					});
					return;
				case 'keyframe':
					if ( ! qdata.quad.keyframe[ attach.id ] )
						return;
					if ( ! mixed.keyframe )
						mixed.keyframe = qdata.quad.keyframe[ attach.id ];
					return;
				case 'hitbox':
					if ( ! qdata.quad.hitbox[ attach.id ] )
						return;
					if ( ! mixed.hitbox )
						mixed.hitbox   = qdata.quad.hitbox[ attach.id ];
					return;
			} // switch ( attach.type )
		}
		function is_canmixed( is_mix, objcur, objnxt ){
			if ( ! is_mix )  return false;
			if ( ! objcur )  return false;
			if ( ! objnxt )  return false;
			if ( objcur.layer.length !== objnxt.layer.length )
				return false;
			return true;
		}

		var mixcur = {
			keyframe : 0,
			hitbox   : 0,
		};
		var mixnxt = {
			keyframe : 0,
			hitbox   : 0,
		};
		getmixed( mixcur, cur );
		getmixed( mixnxt, nxt );
		var mixent = $.copy_object(mixcur);

		if ( is_canmixed(keymix, mixcur.keyframe, mixnxt.keyframe) ){
			for ( var i=0; i < mixcur.keyframe.layer.length; i++ ){
				if ( ! mixcur.keyframe.layer[i] )
					continue;
				if ( ! mixnxt.keyframe.layer[i] )
					continue;
				mixent.keyframe.layer[i].dstquad = Q.math.quad_mix( rate , mixcur.keyframe.layer[i].dstquad , mixnxt.keyframe.layer[i].dstquad );
				mixent.keyframe.layer[i].fogquad = Q.math.fog_mix ( rate , mixcur.keyframe.layer[i].fogquad , mixnxt.keyframe.layer[i].fogquad );
			} // for ( var i=0; i < mixcur.keyframe.length; i++ )
		}

		if ( is_canmixed(hitmix, mixcur.hitbox, mixnxt.hitbox) ){
			for ( var i=0; i < mixcur.hitbox.layer.length; i++ ){
				if ( ! mixcur.hitbox.layer[i] )
					continue;
				if ( ! mixnxt.hitbox.layer[i] )
					continue;
				mixent.hitbox.layer[i].hitquad = Q.math.quad_mix( rate , mixcur.hitbox.layer[i].hitquad , mixnxt.hitbox.layer[i].hitquad );
			} // for ( var i=0; i < mixcur.hitbox.length; i++ )
		}

		// return attach object
		var id = qdata.quad.__MIX.length;
		qdata.quad.__MIX.push(mixent);
		return {
			'type' : '__MIX',
			'id'   : id,
		};
	}

	__.anim_time_index = function( fps, anim ){
		var len = anim.timeline.length;
		var cur = 0;
		while (1){
			fps -= anim.timeline[cur].time;
			if ( fps < 0 )
				return [cur,-fps];

			cur++;
			if ( cur >= len ){
				if ( anim.loop_id < 0 )
					return [-1,0];
				cur = anim.loop_id;
			}
		} // while (1)
	}

	__.anim_current = function( qdata, aid, mat4, color ){
		var ret = {
			attach : 0,
			mat4   : mat4,
			color  : color,
		}

		// check for valid range
		if ( qdata.anim_fps < 0 )
			return ret;
		var anim = qdata.quad.animation[aid];

		// get current frame
		var t = __.anim_time_index(qdata.anim_fps, anim);
		var curid = t[0];
		if ( curid < 0 )
			return ret;
		var cur = anim.timeline[curid];

		// get next frame
		var nxtid = curid + 1;
		if ( nxtid >= anim.timeline.length ){
			if ( anim.loop_id < 0 )
				nxtid = curid;
			else
				nxtid = anim.loop_id;
		}
		var nxt = anim.timeline[nxtid];

		// nothing to mix
		ret.attach = cur.attach;
		if ( curid === nxtid ){
			ret.mat4  = Q.math.matrix_multi44( ret.mat4 , cur.matrix );
			ret.color = Q.math.vec4_multi    ( ret.color, cur.color  );
			return ret;
		}

		// mixing tests
		var m4, c4;
		var rate = t[1] / cur.time;

		// mix matrix
		if ( cur.matrix_mix )
			m4 = Q.math.matrix_mix( rate, cur.matrix, nxt.matrix );
		else
			m4 = cur.matrix;
		ret.mat4 = Q.math.matrix_multi44( ret.mat4 , m4 );

		// mix color
		if ( cur.color_mix )
			c4 = Q.math.color_mix( rate, cur.color , nxt.color  );
		else
			c4 = cur.color;
		ret.color = Q.math.vec4_multi( ret.color, c4 );

		// layer mixing test
		if ( ! cur.keyframe_mix && ! cur.hitbox_mix )
			return ret;

		ret.attach = __.mix_attach(qdata, cur.attach, nxt.attach, rate, cur.keyframe_mix, cur.hitbox_mix);
		return ret;
	}

	//////////////////////////////

	__.draw_skeleton = function( qdata, sid, mat4, color ){
		var bone = qdata.quad.skeleton[sid].bone;
		bone.forEach(function(bv,bk){
			__.draw_attach(qdata, bv.attach, mat4, color);
		});
	}

	//////////////////////////////

	$.is_valid_attach = function( qdata, type, id ){
		if ( ! Array.isArray( qdata.quad[ type ] ) )
			return false;
		if ( ! qdata.quad[ type ][ id ] )
			return false;
		return true;
	}

	__.draw_attach = function( qdata, attach, mat4, color ){
		if ( ! $.is_valid_attach(qdata, attach.type, attach.id) )
			return;
		switch ( attach.type ){
			case 'keyframe':
				return __.draw_keyframe( qdata, attach.id, mat4, color );
			case 'animation':
				var t = __.anim_current( qdata, attach.id, mat4, color );
				if ( ! t.attach )
					return;
				return __.draw_attach( qdata, t.attach, t.mat4, t.color );
			case 'slot':
				qdata.quad.slot[ attach.id ].forEach(function(sv,sk){
					__.draw_attach(qdata, sv, mat4, color);
				});
				return;
			case 'hitbox':
				if ( ! qdata.is_hits )
					return;
				return __.draw_hitbox( qdata, attach.id, mat4 );
			case 'skeleton':
				return __.draw_skeleton( qdata, attach.id, mat4, color );
			case '__MIX':
				return __.draw_MIX( qdata, attach.id, mat4, color );
			case 'list':
				var qid = qdata.quad.list[ attach.id ];
				if ( $.is_undef(qid) || qid < 0 )
					return;
				return $.qdata_draw( qdata.list[qid], mat4, color );
		} // switch ( attach.type )
	}

	$.qdata_draw = function( qdata, mat4, color ){
		if ( ! qdata.quad )
			return;
		var m4 = Q.math.matrix_multi44( mat4, qdata.matrix );
		var c4 = Q.math.vec4_multi(color, qdata.color);
		return __.draw_attach(qdata, qdata.attach, m4, c4);
	}

	$.qdata_clear = function( qdata ){
		if ( ! qdata.quad )
			return;
		Q.gl.clear();
		qdata.is_draw    = false;
		qdata.line_index = 0;
		qdata.quad.__MIX = [];
	}

	$.viewer_autozoom = function( qdata ){
		var canvsz  = Q.gl.canvas_size();
		var sprsize = Q.export.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		if ( ! sprsize )
			return 1.0;

		var symm = Q.math.rect_symmetry(sprsize);
		var zoomx = (canvsz[0] * 1.0) / symm[0];
		var zoomy = (canvsz[1] * 1.5) / symm[1];
		return ( zoomx < zoomy ) ? zoomx : zoomy;
	}

	$.viewer_camera = function( qdata, autozoom ){
		var canvsz = Q.gl.canvas_size();

		qdata.zoom = 1.0;
		var movex = canvsz[0] * 0  ; // no change
		var movey = canvsz[1] * 0.5; // half downward

		if ( autozoom > 0.0 )
			qdata.zoom = autozoom;
		else
			qdata.zoom = $.viewer_autozoom(qdata);

		var m4 = Q.math.matrix4();
		m4[0+3] = movex;
		m4[4+3] = movey;

		m4[0+0] = qdata.zoom;
		m4[4+1] = qdata.zoom;
		if ( qdata.is_flipx )  m4[0+0] = -m4[0+0];
		if ( qdata.is_flipy )  m4[4+1] = -m4[4+1];
		return m4;
	}

	//////////////////////////////

} // function QuadFunc(Q)

	function QuadMath(Q){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.is_int_pow2 = function( int ){
		// 100 & ff === 0
		var rem = int & (int - 1);
		return ( rem === 0 );
	}

	$.clamp = function( n, min, max ){
		if ( n < min )  return min;
		if ( n > max )  return max;
		return n;
	}

	$.rect_symmetry = function( rect ){
		var abs = [
			Math.abs(rect[0]) , Math.abs(rect[1]) ,
			Math.abs(rect[2]) , Math.abs(rect[3]) ,
		];
		var maxx = ( abs[0] > abs[2] ) ? abs[0] : abs[2];
		var maxy = ( abs[1] > abs[3] ) ? abs[1] : abs[3];
		return [ maxx , maxy ];
	}

	$.vram_srcquad = function( quad, pos ){
		if ( ! quad )  return 0; // fog color only
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			xy4[i+0] = quad[i+0] + pos[0];
			xy4[i+1] = quad[i+1] + pos[1];
		}
		return xy4;
	}

	$.css_color = function( css ){
		// css = '#rrggbbaa'
		if ( typeof css !== 'string' || ! /^#[0-9a-fA-F]{8}$/.test(css) )
			return [1,1,1,1];

		var div = 1.0 / 255;
		var rgba = [
			parseInt( css.substring(1,3) , 16 ) * div ,
			parseInt( css.substring(3,5) , 16 ) * div ,
			parseInt( css.substring(5,7) , 16 ) * div ,
			parseInt( css.substring(7,9) , 16 ) * div ,
		];
		return rgba;
	}

	//////////////////////////////

	$.vec_resize = function( len, vec ){
		if ( ! Array.isArray(vec) )
			return;
		while ( vec.length < len )
			vec.push(1);
		while ( vec.length > len ){
			var last = vec.pop() || 1.0;
			var z = ( last == 0 ) ? 0 : 1.0 / last;
			for ( var i=0; i < vec.length; i++ )
				vec[i] *= z;
		} // while ( vec.length > len )
	}

	$.vec_multi = function( v, f ){
		if ( ! Array.isArray(v) )
			return;
		for ( var i=0; i < v.length; i++ )
			v[i] *= f;
	}

	$.vec4_multi = function( v1, v2 ){
		var v4 = [
			v1[0] * v2[0],
			v1[1] * v2[1],
			v1[2] * v2[2],
			v1[3] * v2[3],
		];
		return v4;
	}

	//////////////////////////////

	$.matrix4 = function(){
		var m4 = [
			1,0,0,0,
			0,1,0,0,
			0,0,1,0,
			0,0,0,1,
		];
		return m4;
	}

	$.matrix_multi12 = function( v, m ){
		$.vec_resize(2,v);
		var vm = [
			v[0]*m[0] + v[1]*m[2] ,
			v[0]*m[1] + v[1]*m[3] ,
		];
		return vm;
	}

	$.matrix_multi13 = function( v, m ){
		$.vec_resize(3,v);
		var vm = [
			v[0]*m[0] + v[1]*m[3] + v[2]*m[6] ,
			v[0]*m[1] + v[1]*m[4] + v[2]*m[7] ,
			v[0]*m[2] + v[1]*m[5] + v[2]*m[8] ,
		];
		return vm;
	}

	$.matrix_multi14 = function( v, m ){
		$.vec_resize(4,v);
		var vm = [
			v[0]*m[0] + v[1]*m[4] + v[2]*m[ 8] + v[3]*m[12] ,
			v[0]*m[1] + v[1]*m[5] + v[2]*m[ 9] + v[3]*m[13] ,
			v[0]*m[2] + v[1]*m[6] + v[2]*m[10] + v[3]*m[14] ,
			v[0]*m[3] + v[1]*m[7] + v[2]*m[11] + v[3]*m[15] ,
		];
		return vm;
	}

	$.matrix_multi21 = function( m, v ){
		$.vec_resize(2,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] ,
			m[2]*v[0] + m[3]*v[1] ,
		];
		return mv;
	}

	$.matrix_multi31 = function( m, v ){
		$.vec_resize(3,v);
		var mv = [
			m[0]*v[0] + m[1]*v[1] + m[2]*v[2] ,
			m[3]*v[0] + m[4]*v[1] + m[5]*v[2] ,
			m[6]*v[0] + m[7]*v[1] + m[8]*v[2] ,
		];
		return mv;
	}

	$.matrix_multi41 = function( m, v ){
		$.vec_resize(4,v);
		var mv = [
			m[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3] ,
			m[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3] ,
			m[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3] ,
			m[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3] ,
		];
		return mv;
	}

	$.matrix_multi22 = function( m2a, m2b ){
		if ( ! m2a && ! m2b )  return 0;
		if ( ! m2a )  return m2b;
		if ( ! m2b )  return m2a;
		var m2 = [
			m2a[0]*m2b[0] + m2a[1]*m2b[2],
			m2a[0]*m2b[1] + m2a[1]*m2b[3],

			m2a[2]*m2b[0] + m2a[3]*m2b[2],
			m2a[2]*m2b[1] + m2a[3]*m2b[3],
		];
		return m2;
	}

	$.matrix_multi33 = function( m3a, m3b ){
		if ( ! m3a && ! m3b )  return 0;
		if ( ! m3a )  return m3b;
		if ( ! m3b )  return m3a;
		var m3 = [
			m3a[0]*m3b[0] + m3a[1]*m3b[3] + m3a[2]*m3b[6],
			m3a[0]*m3b[1] + m3a[1]*m3b[4] + m3a[2]*m3b[7],
			m3a[0]*m3b[2] + m3a[1]*m3b[5] + m3a[2]*m3b[8],

			m3a[3]*m3b[0] + m3a[4]*m3b[3] + m3a[5]*m3b[6],
			m3a[3]*m3b[1] + m3a[4]*m3b[4] + m3a[5]*m3b[7],
			m3a[3]*m3b[2] + m3a[4]*m3b[5] + m3a[5]*m3b[8],

			m3a[6]*m3b[0] + m3a[7]*m3b[3] + m3a[8]*m3b[6],
			m3a[6]*m3b[1] + m3a[7]*m3b[4] + m3a[8]*m3b[7],
			m3a[6]*m3b[2] + m3a[7]*m3b[5] + m3a[8]*m3b[8],
		];
		return m3;
	}

	$.matrix_multi44 = function( m4a, m4b ){
		if ( ! m4a && ! m4b )  return 0;
		if ( ! m4a )  return m4b;
		if ( ! m4b )  return m4a;
		var m4 = [
			m4a[ 0]*m4b[0] + m4a[ 1]*m4b[4] + m4a[ 2]*m4b[ 8] + m4a[ 3]*m4b[12],
			m4a[ 0]*m4b[1] + m4a[ 1]*m4b[5] + m4a[ 2]*m4b[ 9] + m4a[ 3]*m4b[13],
			m4a[ 0]*m4b[2] + m4a[ 1]*m4b[6] + m4a[ 2]*m4b[10] + m4a[ 3]*m4b[14],
			m4a[ 0]*m4b[3] + m4a[ 1]*m4b[7] + m4a[ 2]*m4b[11] + m4a[ 3]*m4b[15],

			m4a[ 4]*m4b[0] + m4a[ 5]*m4b[4] + m4a[ 6]*m4b[ 8] + m4a[ 7]*m4b[12],
			m4a[ 4]*m4b[1] + m4a[ 5]*m4b[5] + m4a[ 6]*m4b[ 9] + m4a[ 7]*m4b[13],
			m4a[ 4]*m4b[2] + m4a[ 5]*m4b[6] + m4a[ 6]*m4b[10] + m4a[ 7]*m4b[14],
			m4a[ 4]*m4b[3] + m4a[ 5]*m4b[7] + m4a[ 6]*m4b[11] + m4a[ 7]*m4b[15],

			m4a[ 8]*m4b[0] + m4a[ 9]*m4b[4] + m4a[10]*m4b[ 8] + m4a[11]*m4b[12],
			m4a[ 8]*m4b[1] + m4a[ 9]*m4b[5] + m4a[10]*m4b[ 9] + m4a[11]*m4b[13],
			m4a[ 8]*m4b[2] + m4a[ 9]*m4b[6] + m4a[10]*m4b[10] + m4a[11]*m4b[14],
			m4a[ 8]*m4b[3] + m4a[ 9]*m4b[7] + m4a[10]*m4b[11] + m4a[11]*m4b[15],

			m4a[12]*m4b[0] + m4a[13]*m4b[4] + m4a[14]*m4b[ 8] + m4a[15]*m4b[12],
			m4a[12]*m4b[1] + m4a[13]*m4b[5] + m4a[14]*m4b[ 9] + m4a[15]*m4b[13],
			m4a[12]*m4b[2] + m4a[13]*m4b[6] + m4a[14]*m4b[10] + m4a[15]*m4b[14],
			m4a[12]*m4b[3] + m4a[13]*m4b[7] + m4a[14]*m4b[11] + m4a[15]*m4b[15],
		];
		return m4;
	}

	$.matrix_det2 = function( m2 ){
		return (m2[0]*m2[3] - m2[1]*m2[2]);
	}

	$.matrix_inv2 = function( m2 ){
		var det = $.matrix_det2(m2);
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var mco = [
			 m2[3] * det_inv , -m2[1] * det_inv ,
			-m2[2] * det_inv ,  m2[0] * det_inv ,
		];
		return mco;
	}

	$.matrix_inv3 = function( m3 ){
		// | 0 1 2 |
		// | 3 4 5 |
		// | 6 7 8 |
		var mdet = [
			$.matrix_det2([ m3[4],m3[5],m3[7],m3[8] ]),
			$.matrix_det2([ m3[3],m3[5],m3[6],m3[8] ]),
			$.matrix_det2([ m3[3],m3[4],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[7],m3[8] ]),
			$.matrix_det2([ m3[0],m3[2],m3[6],m3[8] ]),
			$.matrix_det2([ m3[0],m3[1],m3[6],m3[7] ]),

			$.matrix_det2([ m3[1],m3[2],m3[4],m3[5] ]),
			$.matrix_det2([ m3[0],m3[2],m3[3],m3[5] ]),
			$.matrix_det2([ m3[0],m3[1],m3[3],m3[4] ]),
		];

		var mco = [
			 mdet[0] , -mdet[3] ,  mdet[6] ,
			-mdet[1] ,  mdet[4] , -mdet[7] ,
			 mdet[2] , -mdet[5] ,  mdet[8] ,
		];

		var det = m3[0]*mco[0] + m3[1]*mco[3] + m3[2]*mco[6];
		if ( det === 0 )
			return 0;
		var det_inv = 1.0 / det;
		var i = 9;
		while ( i > 0 ){
			i--;
			mco[i] *= det_inv;
		}
		return mco;
	}

	//////////////////////////////

	$.cross = function( a, b ){
		$.vec_resize(3,a);
		$.vec_resize(3,b);
		// x = y1*z2 - y2*z1
		// y = z1*x2 - z2*x1
		// z = x1*y2 - x2*y1
		var x = a[1]*b[2] - b[1]*a[2];
		var y = a[2]*b[0] - b[2]*a[0];
		var z = a[0]*b[1] - b[0]*a[1];
		return [x,y,z];
	}

	$.barycentric_quad = function( quad ){
		var c13  = $.cross( [quad[0],quad[1],1] , [quad[4],quad[5],1] );
		var c24  = $.cross( [quad[2],quad[3],1] , [quad[6],quad[7],1] );
		var bary = $.cross( c13 , c24 );

		if ( bary[2] == 0 )
			return 0;
		var z = 1.0 / bary[2];
		return [ bary[0]*2 , bary[1]*z ];
	}

	$.is_convex_quad = function( quad, bary=0 ){
		if ( ! bary )
			bary = $.barycentric_quad(quad);
		if ( ! bary )
			return false;

		// barycentric is a point on the line from corner to corner
		var corner = [
			[0,1 , 4,5], // test line 1-3
			[2,3 , 6,7], // test line 2-4
		];
		var x, y;
		for ( var i=0; i < 2; i++ ){
			var c = corner[i];
			var x1 = Math.min(quad[ c[0] ] , quad[ c[2] ]);
			var y1 = Math.min(quad[ c[1] ] , quad[ c[3] ]);
			var x2 = Math.max(quad[ c[0] ] , quad[ c[2] ]);
			var y2 = Math.max(quad[ c[1] ] , quad[ c[3] ]);

			if ( bary[0] < x1 || bary[0] > x2 )  continue;
			if ( bary[1] < y1 || bary[1] > y2 )  continue;
			return true;
		} // for ( var i=0; i < 2; i++ )

		return false;
	}

	$.perspective_mat3 = function( quad ){
		var v = [
			[ quad[0],quad[1],1 ],
			[ quad[2],quad[3],1 ],
			[ quad[4],quad[5],1 ],
			[ quad[6],quad[7],1 ],
		];

		// 0 1
		// 3 2
		var c = [
			$.cross( $.cross(v[0],v[2]) , $.cross(v[1],v[3]) ), // corner-corner
			$.cross( $.cross(v[0],v[1]) , $.cross(v[3],v[2]) ), //    top-bottom
			$.cross( $.cross(v[0],v[3]) , $.cross(v[1],v[2]) ), //   left-right
		];
		var m3 = [
			c[0][0] , c[1][0] , c[2][0] ,
			c[0][1] , c[1][1] , c[2][1] ,
			c[0][2] , c[1][2] , c[2][2] ,
		];
		return m3;
	}

	$.perspective_quad = function( dst ){
		// matrix * SRC = DST
		//       matrix = DST * SRC_inv
		//          SRC = matrix_inv * DST
		var dst3 = $.perspective_mat3(dst);

		// var SRC     = pre-computed
		// var SRC_inv = pre-computed
		var src3_inv = [
			 0     , 0     ,  0.005 ,
			-0.001 , 0     ,  0.015 ,
			 0     , 0.001 , -0.015 ,
		];
		var mat3 = $.matrix_multi33(dst3, src3_inv);

		var t = [
			$.matrix_multi31( mat3, [10,10] ),
			$.matrix_multi31( mat3, [20,10] ),
			$.matrix_multi31( mat3, [20,20] ),
			$.matrix_multi31( mat3, [10,20] ),
		];
		return [].concat(t[0],t[1],t[2],t[3]);
	}



	//////////////////////////////

	$.matrix_mix = function( rate, cur, next ){
		if ( ! cur && ! next )  return 0; // both identidy matrix
		if ( ! cur  )  cur  = $.matrix4();
		if ( ! next )  next = $.matrix4();
		// 4/4 = rate 1    = cur * 1    + next * 0
		// 3/4 = rate 0.75 = cur * 0.75 + next * 0.25
		// 2/4 = rate 0.5  = cur * 0.5  + next * 0.5
		// 1/4 = rate 0.25 = cur * 0.25 + next * 0.75
		// 0/4 = rate 0    = cur * 0    + next * 1
		var rev = 1.0 - rate;
		var m4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			m4[i] = (cur[i] * rate) + (next[i] * rev);
		return m4;
	}

	$.color_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.color_mix',cur,next);
		var rev = 1.0 - rate;
		var c4  = [0,0,0,0];
		for ( var i=0; i < 4; i++ )
			c4[i] = (cur[i] * rate) + (next[i] * rev);
		return c4;
	}

	$.quad_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.quad_mix',cur,next);
		var rev = 1.0 - rate;
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i++ )
			xy4[i] = (cur[i] * rate) + (next[i] * rev);
		return xy4;
	}

	$.fog_mix = function( rate, cur, next ){
		if ( ! cur || ! next )
			Q.func.error('math.fog_mix',cur,next);
		var rev = 1.0 - rate;
		var f4  = [0,0,0,0 , 0,0,0,0 , 0,0,0,0 , 0,0,0,0];
		for ( var i=0; i < 16; i++ )
			f4[i] = (cur[i] * rate) + (next[i] * rev);
		return f4;
	}

	// order matters
	//   (A*B)*C === A*(B*C)
	//    A*B    !== B*A
	$.rect_multi4 = function( mat4, rect ){
		if ( ! mat4 )  return rect; // mat4=0 is identidy matrix , rect=no change
		var xy2 = [0,0 , 0,0];
		for ( var i=0; i < 4; i += 2 ){
			var x = rect[i+0];
			var y = rect[i+1];
			xy2[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy2[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy2;
	}

	$.quad_multi4 = function( mat4, quad ){
		if ( ! mat4 )  return quad; // mat4=0 is identidy matrix , quad=no change
		var xy4 = [0,0 , 0,0 , 0,0 , 0,0];
		for ( var i=0; i < 8; i += 2 ){
			var x = quad[i+0];
			var y = quad[i+1];
			xy4[i+0] = mat4[0]*x + mat4[1]*y + mat4[2] + mat4[3];
			xy4[i+1] = mat4[4]*x + mat4[5]*y + mat4[6] + mat4[7];
		}
		return xy4;
	}

	// color * fogquad
	$.fog_multi4 = function( color, quad ){
		var c16 = [
			// r                g                   b                   a
			quad[ 0]*color[0] , quad[ 1]*color[1] , quad[ 2]*color[2] , quad[ 3]*color[3] , // c1
			quad[ 4]*color[0] , quad[ 5]*color[1] , quad[ 6]*color[2] , quad[ 7]*color[3] , // c2
			quad[ 8]*color[0] , quad[ 9]*color[1] , quad[10]*color[2] , quad[10]*color[3] , // c3
			quad[12]*color[0] , quad[13]*color[1] , quad[14]*color[2] , quad[15]*color[3] , // c4
		];
		return c16;
	}

	//////////////////////////////

} // function QuadMath

	function QuadExport(Q){
	var $ = this; // public
	var __ = {};  // private

	//////////////////////////////

	__.rect_compare = function( rect, xy ){
		if ( rect[0] > xy[0] )  rect[0] = xy[0]; // x1
		if ( rect[1] > xy[1] )  rect[1] = xy[1]; // y1
		if ( rect[2] < xy[2] )  rect[2] = xy[2]; // x2
		if ( rect[3] < xy[3] )  rect[3] = xy[3]; // y2
	}

	$.rect_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;

		var max  = 1 << 30;
		var rect = 0;
		var is_null = true;

		var cur = qdata.quad[ type ][ id ];
		switch ( type ){
			case 'keyframe':
			case 'hitbox':
				if ( cur.__RECT )
					return cur.__RECT;

				var quad = '';
				if ( type === 'keyframe' )  quad = 'dstquad';
				if ( type === 'hitbox'   )  quad = 'hitquad';
				cur.layer.forEach(function(lv,lk){
					if ( ! lv || ! lv[quad] )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					var dst = lv[quad];
					for ( var i=0; i < 8; i += 2 ){
						if ( rect[0] > dst[i+0] )  rect[0] = dst[i+0]; // x1
						if ( rect[1] > dst[i+1] )  rect[1] = dst[i+1]; // y1
						if ( rect[2] < dst[i+0] )  rect[2] = dst[i+0]; // x2
						if ( rect[3] < dst[i+1] )  rect[3] = dst[i+1]; // y2
					} // for ( var i=0; i < 8; i += 2 )
				});
				cur.__RECT = rect;
				return rect;

			case 'slot':
				cur.forEach(function(sv,sk){
					var xy = $.rect_attach(qdata, sv.type, sv.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					__.rect_compare(rect, xy);
				});
				return rect;

			case 'animation':
				if ( cur.__RECT )
					return cur.__RECT;

				cur.timeline.forEach(function(tv,tk){
					if ( ! tv.attach )
						return;
					var xy = $.rect_attach(qdata, tv.attach.type, tv.attach.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					var xy2 = Q.math.rect_multi4(tv.matrix, xy);
					var t;
					if ( xy2[0] > xy2[2] ){ // if x1 > x2  swap()
						t = xy2[0];
						xy2[0] = xy[2];
						xy2[2] = t;
					}
					if ( xy2[1] > xy[3] ){ // if y1 > y2  swap()
						t = xy2[1];
						xy2[1] = xy2[3];
						xy2[3] = t;
					}
					__.rect_compare(rect, xy2);
				});
				cur.__RECT = rect;
				return rect;

			case 'skeleton':
				if ( cur.__RECT )
					return cur.__RECT;

				cur.bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var xy = $.rect_attach(qdata, bv.attach.type, bv.attach.id);
					if ( ! xy )
						return;
					if ( ! rect )
						rect = [max,max,-max,-max];

					__.rect_compare(rect, xy);
				});
				cur.__RECT = rect;
				return rect;
		} // switch ( type )
		return 0;
	}

	$.is_loop_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var loop = $.is_loop_attach(qdata, slot[i].type, slot[i].id);
					if ( loop )
						return true;
				}
				return false;
			case 'animation':
				var loop = qdata.quad.animation[id].loop_id;
				if ( loop < 0 )
					return false;
				else
					return true;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var loop = $.is_loop_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( loop )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.is_mix_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return false;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				for ( var i=0; i < slot.length; i++ ){
					var mix = $.is_mix_attach(qdata, slot[i].type, slot[i].id);
					if ( mix )
						return true;
				}
				return false;
			case 'animation':
				var time = qdata.quad.animation[id].timeline;
				for ( var i=0; i < time.length; i++ ){
					var tv = time[i];
					var mix = 0;
					mix |= tv.matrix_mix;
					mix |= tv.color_mix;
					mix |= tv.keyframe_mix;
					mix |= tv.hitbox_mix;
					if ( mix )
						return true;
				}
				return false;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				for ( var i=0; i < bone.length; i++ ){
					if ( ! bone[i] || ! bone[i].attach )
						continue;
					var mix = $.is_mix_attach(qdata, bone[i].attach.type, bone[i].attach.id);
					if ( mix )
						return true;
				}
				return false;
		} // switch ( type )
		return false;
	}

	$.time_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return 0;
		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var time = 0;
				for ( var i=0; i < slot.length; i++ ){
					var t = $.time_attach(qdata, slot[i].type, slot[i].id);
					if ( t > time )
						time = t;
				}
				return time;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var time = 0;
				anim.forEach(function(av,ak){
					time += av.time;
				});
				return time;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var time = 0;
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					var t = $.time_attach(qdata, bv.attach.type, bv.attach.id);
					if ( t > time )
						time = t;
				});
				return time;
		} // switch ( type )
		return 0;
	}


	$.list_attach = function( qdata, type, id ){
		if ( ! Q.func.is_valid_attach(qdata, type, id) )
			return [];

		switch ( type ){
			case 'slot':
				var slot = qdata.quad.slot[id];
				var list = [];
				slot.forEach(function(sv,sk){
					list.push( sv.type +','+ sv.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'animation':
				var anim = qdata.quad.animation[id].timeline;
				var list = [];
				anim.forEach(function(tv,tk){
					if ( ! tv || ! tv.attach )
						return;
					list.push( tv.attach.type +','+ tv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
			case 'skeleton':
				var bone = qdata.quad.skeleton[id].bone;
				var list = [];
				bone.forEach(function(bv,bk){
					if ( ! bv || ! bv.attach )
						return;
					list.push( bv.attach.type +','+ bv.attach.id );
				});
				Q.func.array_clean_dups(list);
				return list;
		} // switch ( type )
		return [];
	}

	//////////////////////////////

	__.bak = {};
	__.backup = function( qdata, canvas, type, id, fps, zoom ){
		__.bak = {
			type  : qdata.attach.type ,
			id    : qdata.attach.id   ,
			fps   : qdata.anim_fps    ,
			zoom  : qdata.zoom        ,
			line  : qdata.is_lines    ,
			hit   : qdata.is_hits     ,
			canvw : canvas.width  ,
			canvh : canvas.height ,
			fname : qdata.name + '_' + type + '_' + id + '_' + fps ,
			start : performance.now() ,
		};
		qdata.attach.type = type;
		qdata.attach.id   = id;
		qdata.anim_fps    = fps;
		qdata.zoom        = zoom;
		qdata.is_lines    = false;
		qdata.is_hits     = false;
	}

	__.restore = function( qdata, canvas, fmt ){
		qdata.attach.type = __.bak.type;
		qdata.attach.id   = __.bak.id;
		qdata.anim_fps    = __.bak.fps;
		qdata.zoom        = __.bak.zoom;
		qdata.is_lines    = __.bak.line;
		qdata.is_hits     = __.bak.hit;
		canvas.width      = __.bak.canvw;
		canvas.height     = __.bak.canvh;
		Q.func.log('download' , __.bak.fname , 'fmt' , fmt , 'time' , performance.now() - __.bak.start);
	}

	__.download = function( fname, dataurl ){
		if ( ! fname || ! dataurl )
			return;

		var a = document.createElement('a');
		a.href = dataurl;
		a.setAttribute('download', fname);
		a.setAttribute('target'  , '_blank');
		a.click();
	}

	//////////////////////////////

	__.export_sheet = function( qdata, canvas ){
		var line_spacing = 1.15;
		var spr_rect = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var sprwh = [
			Math.ceil( (spr_rect[2] - spr_rect[0]) * line_spacing * qdata.zoom ),
			Math.ceil( (spr_rect[3] - spr_rect[1]) * line_spacing * qdata.zoom ),
		];
		var sprmid = [
			(spr_rect[2] + spr_rect[0]) * 0.5 * qdata.zoom,
			(spr_rect[3] + spr_rect[1]) * 0.5 * qdata.zoom,
		];

		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();

		var anim_remain = anim_time - qdata.anim_fps;
		var tilecol = 1;
		var tilerow = 1;
		var tile = [
			Math.floor(texsize / sprwh[0]),
			Math.floor(texsize / sprwh[1]),
		];
		if ( tile[0] >= anim_remain )
			tilecol = anim_remain;
		else {
			tilecol = tile[0];
			var y = Math.ceil(anim_remain / tile[0]);
			tilerow = ( y < tile[1] ) ? y : tile[1];
		}
		canvas.width  = tilecol * sprwh[0];
		canvas.height = tilerow * sprwh[1];

		// canvas from -halftex to +halftex
		// sprite 0,0 is at center
		var halfpos = [
			canvas.width * 0.5 , canvas.height * 0.5,
			sprwh[0]     * 0.5 , sprwh[1]      * 0.5,
		];

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];
		Q.func.qdata_clear(qdata);

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		// from -1.0 to +1.0
		for ( var dy = -halfpos[1]; dy < halfpos[1]; dy += sprwh[1] ){
			if ( qdata.anim_fps >= anim_time )
				continue;

			// from -1.0 to +1.0
			for ( var dx = -halfpos[0]; dx < halfpos[0]; dx += sprwh[0] ){
				if ( qdata.anim_fps >= anim_time )
					continue;

				var m4 = Q.math.matrix4();
				m4[0+3] = dx + halfpos[2] - sprmid[0];
				m4[4+3] = dy + halfpos[3] - sprmid[1];
				m4 = Q.math.matrix_multi44(camera, m4);

				qdata.is_draw = false;
				Q.func.qdata_draw(qdata, m4, color);
				qdata.anim_fps++;
			} // for ( var dx = -halfpos[0]; dx < halfpos[0]; dx += sprwh[0] )
		} // for ( var dy = -halfpos[1]; dy < halfpos[1]; dy += sprwh[1] )

		var fn = __.bak.fname + '.sheet.png';
		__.download(fn, canvas.toDataURL('image/png'));
	}

	__.export_zip = function( qdata, canvas, fmt ){
		var spr_rect = $.rect_attach(qdata, qdata.attach.type, qdata.attach.id);
		var symm = Q.math.rect_symmetry(spr_rect);

		canvas.width  = Math.ceil(symm[0] * qdata.zoom) * 2 + 4;
		canvas.height = Math.ceil(symm[1] * qdata.zoom) * 2 + 4;

		// same number of sprites as sheet
		var anim_time = $.time_attach(qdata, qdata.attach.type, qdata.attach.id);
		var texsize = Q.gl.max_texsize();
		var len  = Math.floor(texsize / canvas.width) * Math.floor(texsize / canvas.height);
		var list = {};

		var camera = Q.math.matrix4();
		var color  = [1,1,1,1];

		camera[0+0] = ( qdata.is_flipx ) ? -qdata.zoom : qdata.zoom;
		camera[4+1] = ( qdata.is_flipy ) ? -qdata.zoom : qdata.zoom;

		var proall = [];
		var i = 0;
		while ( i < len ){
			if ( qdata.anim_fps >= anim_time )
				break;
			Q.func.qdata_clear(qdata);
			Q.func.qdata_draw (qdata, camera, color);

			var p = new Promise(function(ok,err){
				switch ( fmt ){
					case 'png':
						// %06d.png
						var pad = '000000' + qdata.anim_fps + '.png';
						var fn  = pad.substring( pad.length - 10 );
						Q.gl.to_uint8().then(function(res){
							ok([fn,res]);
						});
						break;
					case 'rgba':
						// %06d.rgba
						var pad = '000000' + qdata.anim_fps + '.rgba';
						var arg = [
							pad.substring( pad.length - 11 ),
							Q.gl.read_RGBA()
						];
						ok(arg);
						break;
				} // switch ( fmt )
			}).then(function(res){
				list[ res[0] ] = res[1];
			});
			proall.push(p);

			qdata.anim_fps++;
			i++;
		} // while ( i < len )

		return Promise.all(proall).then(function(res){
			var blob = new Blob(
				[ Q.binary.zipwrite(list) ],
				{ type : 'application/zip' }
			);
			var reader = new FileReader;
			reader.onload = function(){
				var fn = __.bak.fname + '.' + fmt + '.zip';
				__.download(fn, reader.result);
			};
			reader.readAsDataURL(blob);
		});
	}

	//////////////////////////////

	$.export = function( fmt, qdata, canvas, type, id, fps, zoom ){
		if ( zoom < 0.1 || zoom > 10.0 )
			return;

		Promise.resolve().then(function(r){
			__.backup(qdata, canvas, type, id, fps, zoom);
			switch ( fmt ){
				case 'png' :  return  __.export_sheet(qdata, canvas);
				case 'zip' :  return  __.export_zip(qdata, canvas, 'png');
				case 'rgba':  return  __.export_zip(qdata, canvas, 'rgba');
				default:      return 0;
			} // switch ( fmt )
		}).then(function(r){
			// performance
			//   png     69 ms     24,178 byte
			//   zip    121 ms     58,852 byte
			//   rgba  1470 ms  1,355,530 byte
			__.restore(qdata, canvas, fmt);
		});
	}

	//////////////////////////////

} // function QuadExport

	function BinaryReader(){
	var $ = this; // public
	//var __ = {};  // private

	//////////////////////////////

	$.uint2txt = function( buf ){
		buf = new Uint8Array(buf);
		return $.getstr(buf, 0, buf.byteLength);
	}

	$.cat_uint8 = function( a, b ){
		var c = new Uint8Array( a.byteLength + b.byteLength );
		c.set(a, 0);
		c.set(b, a.byteLength);
		return c;
	}

	//////////////////////////////

	$.getint = function( buf, pos, len ){
		var int = 0;
		for ( var i=0; i < len; i++ )
			int |= (buf[pos+i] << (i*8));
		return int;
	}

	$.getstr = function( buf, pos, len ){
		var str = '';
		for ( var i=0; i < len; i++ )
			str += String.fromCharCode( buf[pos+i] );
		return str;
	}

	$.getsub = function( buf, pos, len ){
		var sub = new Uint8Array(len);
		for ( var i=0; i < len; i++ )
			sub[i] = buf[pos+i];
		return sub;
	}

	$.zipread = function( zipbuf ){
		zipbuf = new Uint8Array(zipbuf)
		var list = {};
		var pos  = 0;
		while (1)
		{
			var mgc = $.getint(zipbuf, pos, 4);
			if ( mgc !== 0x04034b50 )  // PK34
				break;

			var sz1 = $.getint(zipbuf, pos + 0x12, 4); // data size
			var sz2 = $.getint(zipbuf, pos + 0x1a, 2); // filename length
			var sz3 = $.getint(zipbuf, pos + 0x1c, 2); // extra length

			// uncompressed file/store only
			if ( zipbuf[pos + 8] === 0 ){
				var fn = $.getstr(zipbuf, pos + 0x1e            , sz2);
				var dt = $.getsub(zipbuf, pos + 0x1e + sz2 + sz3, sz1);
				list[fn] = dt;
			}

			pos += (0x1e + sz1 + sz2 + sz3);
		} // while (1)
		return list;
	}

	//////////////////////////////

	$.setint = function( buf, pos, len, int ){
		for ( var i=0; i < len; i++ ){
			var b = int >> (i*8);
			buf[pos+i] = b & 0xff;
		}
	}

	$.setstr = function( buf, pos, str ){
		for ( var i=0; i < str.length; i++ )
			buf[pos+i] = str.charCodeAt(i);
	}

	$.setsub = function( buf, pos, sub ){
		for ( var i=0; i < sub.byteLength; i++ )
			buf[pos+i] = sub[i];
	}

	$.zipwrite = function( list ){
		var key = Object.keys(list);
		var pk34len = 0;
		var pk12len = 0;
		var pk56len = 0x16;

		var fnlen, dtlen, dtcrc;
		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			pk34len += (0x1e + fnlen + dtlen);
			pk12len += (0x2e + fnlen);
		} // for ( var i=0; i < key.length; i++ ){
		var zipbuf = new Uint8Array( pk34len + pk12len + pk56len );

		var pos34 = 0;
		var pos12 = pk34len;
		var pos56 = pk34len + pk12len;

		for ( var i=0; i < key.length; i++ ){
			fnlen = key[i].length;
			dtlen = list[ key[i] ].byteLength;
			dtcrc = $.crc32( list[ key[i] ] );

			$.setint(zipbuf , pos12 , 4 , 0x02014b50);  // PK12
			zipbuf[ pos12 + 0x04 ] = 10;  // ver 1.0
			zipbuf[ pos12 + 0x06 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos12 + 0x10 , dtcrc);
			$.setint(zipbuf , pos12 + 0x14 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos12 + 0x18 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos12 + 0x1c , 2 , fnlen);
			$.setint(zipbuf , pos12 + 0x2a , 4 , pos34);
				pos12 += 0x2e;
			$.setstr(zipbuf , pos12 , key[i]);
				pos12 += fnlen;

			$.setint(zipbuf , pos34 , 4 , 0x04034b50);  // PK34
			zipbuf[ pos34 + 0x04 ] = 10;  // ver 1.0
			$.setsub(zipbuf , pos34 + 0x0e , dtcrc);
			$.setint(zipbuf , pos34 + 0x12 , 4 , dtlen);  // compressed
			$.setint(zipbuf , pos34 + 0x16 , 4 , dtlen);  // uncompressed
			$.setint(zipbuf , pos34 + 0x1a , 2 , fnlen);
				pos34 += 0x1e;
			$.setstr(zipbuf , pos34 , key[i]);
				pos34 += fnlen;
			$.setsub(zipbuf , pos34 , list[ key[i] ]);
				pos34 += dtlen;
		} // for ( var i=0; i < key.length; i++ ){

		$.setint(zipbuf , pos56 , 4, 0x06054b50);  // PK56
		$.setint(zipbuf , pos56 + 0x08 , 2, key.length);  // disk entry
		$.setint(zipbuf , pos56 + 0x0a , 2, key.length);  // total entry
		$.setint(zipbuf , pos56 + 0x0c , 4, pk12len);  // PK12 length
		$.setint(zipbuf , pos56 + 0x10 , 4, pk34len);  // PK12 pos
		return zipbuf;
	}

	//////////////////////////////

	$.crc32 = function( uint8 ){
		uint8 = new Uint8Array(uint8);
		var crc = new Uint16Array([255,255,255,255]);

		// https://stackoverflow.com/questions/21001659/crc32-algorithm-implementation-in-c-without-a-look-up-table-and-with-a-public-li
		// https://web.archive.org/web/20190108202303/http://www.hackersdelight.org/hdcodetxt/crc.c.txt
		// https://web.archive.org/web/20190716204559/http://www.hackersdelight.org/permissions.htm
		function shift(){
			var carry = 0;
			[3,2,1,0].forEach(function(e){
				crc[e] |= (carry << 8);
				carry = crc[e] & 1;
				crc[e] >>= 1;
			});
			return carry;
		}
		function xor( int ){
			var b;
			[0,1,2,3].forEach(function(e){
				b = (int >> (e*8)) & 0xff;
				crc[e] ^= b;
			});
		}

		var len = uint8.byteLength;
		for ( var i=0; i < len; i++ ){
			xor( uint8[i] );
			for ( var j=0; j < 8; j++ ){
				var mask = shift();
				if ( mask )
					xor( 0xedb88320 );
			}
		}
		xor( 0xffffffff );
		return new Uint8Array(crc);
	}

	//////////////////////////////

	// base64
	// 4 * 6-bit ASCII == 3 * 8-bit BINARY
	// in 24-bit sets

	$.to_base64 = function( uint8 ){
		//uint8 = new Uint8Array(uint8);
		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT6  = 0x3f;
		var len = uint8.byteLength;
		var pos = 0;

		var b, b1, b2, b3, b4;
		var b64 = '';
		while ( len >= 3 ){
			b = (uint8[pos+0] << 16) | (uint8[pos+1] << 8) | uint8[pos+2];
				pos += 3;
				len -= 3;

			b1 = (b >> 18) & BIT6;
			b2 = (b >> 12) & BIT6;
			b3 = (b >>  6) & BIT6;
			b4 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + token[b4];
		} // while ( len >= 3 ){

		if ( len === 2 ){
			b = (uint8[pos+0] << 8) | uint8[pos+1];
				b <<= 2

			b1 = (b >> 12) & BIT6;
			b2 = (b >>  6) & BIT6;
			b3 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + token[b3] + '=';
		}
		if ( len === 1 ){
			b = uint8[pos+0];
				b <<= 4;

			b1 = (b >>  6) & BIT6;
			b2 = (b >>  0) & BIT6;
			b64 += token[b1] + token[b2] + '==';
		}
		return b64;
	}

	$.from_base64 = function( b64 ){
		// data URL handling
		var st  = 0;
		var pos = b64.indexOf('base64,');
		if ( pos !== -1 )
			st = pos + 7;

		// must be length % 4 === 0
		var len = b64.length - st;
		if ( len < 1 || (len & 3) !== 0 )
			return '';

		// Uint8Array.reserve()
		var declen = (len >> 2) * 3;
		if ( b64[ b64.length - 1 ] === '=' ){
			declen--;
			if ( b64[ b64.length - 2 ] === '=' )
				declen--;
		}
		var uint8 = new Uint8Array(declen);

		var token = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		var BIT8  = 0xff;

		var b, b1, b2, b3, b4;
		var dpos = 0;
		for ( var pos = st; pos < b64.length; pos += 4 ){
			b1 = token.indexOf( b64[pos+0] );
			b2 = token.indexOf( b64[pos+1] );

			if ( b64[pos+2] === '=' ){
				b = (b1 << 6) | b2;
					b >>= 4;
				uint8[dpos+0] = (b >> 0) & BIT8;
					dpos += 1;
				continue;
			}

			b3 = token.indexOf( b64[pos+2] );
			if ( b64[pos+3] === '=' ){
				b = (b1 << 12) | (b2 << 6) | b3;
					b >>= 2;
				uint8[dpos+0] = (b >> 8) & BIT8;
				uint8[dpos+1] = (b >> 0) & BIT8;
					dpos += 2;
				continue;
			}

			b4 = token.indexOf( b64[pos+3] );
			b = (b1 << 18) | (b2 << 12) | (b3 << 6) | b4;

			uint8[dpos+0] = (b >> 16) & BIT8;
			uint8[dpos+1] = (b >>  8) & BIT8;
			uint8[dpos+2] = (b >>  0) & BIT8;
				dpos += 3;
		} // for ( var pos=0; pos < b64.length; pos += 4 ){
		return uint8;
	}

	//////////////////////////////

} // function BinaryReader


	$.version = 'ver 2024-6-30 (beta)';
	$.gl   = new QuadGL  ($);
	$.func = new QuadFunc($);
	$.math = new QuadMath($);
	$.export = new QuadExport($);
	$.binary = new BinaryReader();

})(QUAD);

function QuadData(qlist){
	var $ = this;
	$.list = qlist;

	// uploaded files
	$.colorize = [];
	$.keyattr  = -1;
	$.hitattr  = -1;
	$.name = '';
	$.quad  = {};
	$.image = []; // { pos:rect , name:string }
	$.vram  = QUAD.gl.create_pixel(255,-1,-1); // white texture

	// activated data
	$.is_wait  = true;
	$.is_draw  = false;
	$.is_hits  = true;
	$.is_lines = true;
	$.is_flipx = false;
	$.is_flipy = false;
	$.zoom   = 1;
	$.matrix = [1,0,0,0 , 0,1,0,0 , 0,0,1,0 , 0,0,0,1];
	$.color  = [1,1,1,1];

	$.attach = {
		type : '',
		id   : 0
	};
	$.anim_fps = 0;
	$.line_index = 0;
}
</script>
</head><body>

<div id='debugger'>
	<p id='debugger_top_nav'>
		<input type='file' id='input_file' multiple class='hidden'>
		<button id='btn_view'>view</button>
		<button id='btn_upload' data-id='0'>upload</button>
	</p>

	<div id='debugger_top_dummy'>&nbsp;</div>
	<h1 id='quad_version'></h1>
	<div class='div_range'>
		<label for='bgcontrast_range'>BG Contrast = </label>
		<span>-</span>
		<input id='bgcontrast_range' type='range' onchange='div_range_span(this);' min='0' max='255' step='1' value='18'>
	</div>
	<h2>Files</h2>
	<ol id='debugger_files'></ol>
	<div id='quad_data'></div>
	<h3>Logs</h3>
	<textarea id='logger' disabled></textarea>
	<p>
		<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/player-mobile.tpl.html' target='_blank'>Latest version</a> -
		<a href='https://rufaswan.github.io/Web2D_Games/quad_player_mobile/spec.html' target='_blank'>QUAD File Spec</a> -
		<a href='https://github.com/rufaswan/Web2D_Games' target='_blank'>Github</a>
	</p>

	<div id='export_menu' data-type='' data-id=''>
		<p><button onclick='button_close(this);'>close</button> Export Menu</p>
		<p><span id='export_name'></span></p>
		<div class='div_range'>
			<label for='export_range'>START = </label>
			<span>-</span>
			<input id='export_range' type='range' onchange='div_range_span(this);' min='0' max='0' step='1' value='0'>
		</div>
		<div class='div_range'>
			<label for='export_times'>ZOOM = </label>
			<span>-</span>
			<input id='export_times' type='range' onchange='div_range_span(this);' min='0.25' max='4.0' step='0.01' value='1.0'>
		</div>
		<p>
			<button onclick='button_export_type(this);'>png</button>
			<button onclick='button_export_type(this);'>zip</button>
			<button onclick='button_export_type(this);'>rgba</button>
		</p>
	</div>
</div>

<div id='viewer'>
	<div id='viewer_xline'></div>
	<div id='viewer_yline'></div>
	<canvas id='canvas'>Canvas not supported</canvas>
	<p id='viewer_top_nav'>
		<button id='btn_debug'>debug</button>
		<button id='btn_lines'>line</button>

		<button id='btn_hitattr'  class='btn_on' title='hitbox layers'>hits</button>
		<button id='btn_keyattr'  title='keyframe layers' >keys</button>
		<button id='btn_colorize' title='custom colors'>color</button>

		<button id='btn_flipx' class='btn_off'>X</button>
		<button id='btn_flipy' class='btn_off'>Y</button>
		<button id='btn_autozoom' class='btn_on' title='autozoom'>zoom</button>
	</p>
	<p id='viewer_bottom_nav'>
		<button id='btn_prev'>&lt;&lt;</button>

		<button id='btn_autonext'>auto</button>
		<button id='btn_cur'>0</button>

		<button id='btn_next'>&gt;&gt;</button>
	</p>

	<div id='colorize_menu'>
		<p><button onclick='button_close(this);'>close</button> Colorize Menu</p>
		<p id='colorize_list'></p>
	</div>
	<div id='keyattr_menu'>
		<p><button onclick='button_close(this);'>close</button> Keyframe Attribute Menu</p>
		<p id='keyattr_list'></p>
	</div>
	<div id='hitattr_menu'>
		<p><button onclick='button_close(this);'>close</button> Hitbox Attribute Menu</p>
		<p id='hitattr_list'></p>
	</div>
</div>

<script>
'use strict';

APP.html          = APP.get_html_id();
APP.selected      = '';
APP.upload_id     = -1;
APP.autozoom      = -1;
APP.is_btn_click  = 0;
APP.is_autonext   = false;
APP.is_redraw     = true;
APP.is_viewer_nav = true;
APP.fps_draw      = 0;
APP.camera        = QUAD.math.matrix4();
APP.color         = [1,1,1,1];
APP.QuadList      = [];

(function(){
	if ( ! QUAD.gl.init(APP.html.canvas) )
		return;

	document.title += ' - ' + QUAD.version;
	APP.html.quad_version.innerHTML = document.title;

	div_range_span(APP.html.bgcontrast_range);
	div_range_span(APP.html.export_range);
	div_range_span(APP.html.export_times);

	// BETWEEN DEBUGGER-VIEWER
	APP.html.btn_view.addEventListener('click', function(){
		APP.display_viewer(APP.html, true);
		APP.is_redraw = true;
	});
	APP.html.btn_debug.addEventListener('click', function(){
		APP.display_viewer(APP.html, false);
		APP.html.logger.innerHTML = QUAD.func.console();
	});

	APP.html.btn_upload.addEventListener('click', function(){
		APP.upload_id = this.getAttribute('data-id');
		APP.html.input_file.click();
		APP.html.logger.innerHTML = QUAD.func.console();
	});
	APP.html.input_file.addEventListener('change', function(){
		QUAD.func.log('QuadList[]', APP.upload_id);
		if ( QUAD.func.is_undef( APP.QuadList[ APP.upload_id ] ) )
			APP.QuadList[ APP.upload_id ] = new QuadData(APP.QuadList);
		var qdata = APP.QuadList[ APP.upload_id ];

		var proall = [];
		for ( var up of this.files )
			proall.push( QUAD.func.upload_promise(up, qdata) );

		Promise.all(proall).then(function(resolve){
			APP.qdata_filetable(qdata, APP.html.debugger_files);
			if ( qdata.name ){
				APP.html.quad_data.innerHTML = '';
				document.title = '[' + qdata.name + '] ' + APP.html.quad_version.innerHTML;

				var buffer = APP.qdata_tagtable(qdata.quad.tag);
				APP.html.quad_data.innerHTML += buffer;

				var quad_main = APP.quad_mainlist(qdata.quad);
				if ( quad_main === -1 )
					return;

				var buffer = '<h2>' + quad_main + '</h2>';
				buffer += '<ul>';
				qdata.quad[quad_main].forEach(function(v,k){
					if ( ! v )
						return;
					buffer += APP.qdata_listing(qdata, quad_main, k);
				});
				buffer += '</ul>';
				APP.html.quad_data.innerHTML += buffer;

				APP.viewer_btn_menu(qdata);
			} // if ( qdata.name )
			APP.html.logger.innerHTML = QUAD.func.console();
		});
	});
	APP.html.bgcontrast_range.addEventListener('change', function(){
		var light = this.value & 0xff;
		var dark  = 0xff - light;
		var root  = document.documentElement;
		root.style.setProperty('--body-bg-color'   , `rgb(${light},${light},${light})`);
		root.style.setProperty('--body-text-color' , `rgb(${dark} ,${dark} ,${dark} )`);
		if ( light & 0x80 ){
			root.style.setProperty('--button-bg-color'   , '#121212');
			root.style.setProperty('--button-text-color' , '#ededed');
		}
		else {
			root.style.setProperty('--button-bg-color'   , '#ededed');
			root.style.setProperty('--button-text-color' , '#121212');
		}
	});

	// VIEWER
	APP.html.canvas.addEventListener('click', function(){
		if ( APP.is_viewer_nav ) {
			APP.html.viewer_top_nav.style.display    = 'none';
			APP.html.viewer_bottom_nav.style.display = 'none';
		} else {
			APP.html.viewer_top_nav.style.display    = 'flex';
			APP.html.viewer_bottom_nav.style.display = 'flex';
		}
		APP.is_viewer_nav = ! APP.is_viewer_nav;
	});
	APP.html.btn_lines.addEventListener('click', function(){
		if ( ! APP.QuadList[0] )
			return;
		APP.QuadList[0].is_lines = ! APP.QuadList[0].is_lines;
		APP.html.btn_lines.innerHTML = ( APP.QuadList[0].is_lines ) ? 'line' : 'tex';
		APP.is_redraw = true;
	});
	APP.html.btn_hitattr.addEventListener('click', function(){
		APP.qdata_toggle(APP.QuadList[0], this, 'is_hits');
		APP.is_redraw = true;
	});
	APP.html.btn_colorize.addEventListener('click', function(){
		APP.html.colorize_menu.style.display = 'block';
		APP.is_redraw = true;
	});
	APP.html.btn_keyattr.addEventListener('click', function(){
		APP.html.keyattr_menu.style.display = 'block';
		APP.is_redraw = true;
	});
	APP.html.btn_flipx.addEventListener('click', function(){
		APP.qdata_toggle(APP.QuadList[0], this, 'is_flipx');
		APP.is_redraw = true;
	});
	APP.html.btn_flipy.addEventListener('click', function(){
		APP.qdata_toggle(APP.QuadList[0], this, 'is_flipy');
		APP.is_redraw = true;
	});
	APP.html.btn_autozoom.addEventListener('click', function(){
		if ( this.classList.contains('btn_on') ){
			APP.button_toggle(this, -1);
			APP.autozoom = 1;
		} else {
			APP.button_toggle(this, 1);
			APP.autozoom = -1;
		}
		if ( APP.QuadList[0] )
			APP.QuadList[0].zoom = APP.autozoom;
		APP.is_redraw = true;
	});

	APP.html.btn_prev.addEventListener('click', function(){
		if ( APP.is_autonext ){
			APP.button_toggle(APP.html.btn_next, -1);
			if ( APP.html.btn_prev.classList.contains('btn_on') ){
				APP.button_toggle(APP.html.btn_prev, -1);
				APP.is_btn_click = 0;
			} else {
				APP.button_toggle(APP.html.btn_prev, 1);
				APP.is_btn_click = -1;
			}
		} else
			APP.is_btn_click = -1;
	});
	APP.html.btn_next.addEventListener('click', function(){
		if ( APP.is_autonext ){
			APP.button_toggle(APP.html.btn_prev, -1);
			if ( APP.html.btn_next.classList.contains('btn_on') ){
				APP.button_toggle(APP.html.btn_next, -1);
				APP.is_btn_click = 0;
			} else {
				APP.button_toggle(APP.html.btn_next, 1);
				APP.is_btn_click = 1;
			}
		} else
			APP.is_btn_click = 1;
	});
	APP.html.btn_autonext.addEventListener('click', function(){
		if ( APP.is_autonext ){
			APP.button_toggle(APP.html.btn_prev, 0);
			APP.button_toggle(APP.html.btn_next, 0);
			APP.is_autonext = false;
		} else {
			APP.button_toggle(APP.html.btn_prev, -1);
			APP.button_toggle(APP.html.btn_next, -1);
			APP.is_autonext = true;
		}
	});

	function render(){
		requestAnimationFrame(render);
		if ( APP.html.viewer.style.display !== 'block' )
			return;
		if ( ! APP.QuadList[0] || ! APP.QuadList[0].name )
			return;
		var qdata = APP.QuadList[0];

		// auto forward by 60/8 fps = 7.5 fps
		if ( (APP.fps_draw & 7) === 0 ){
			APP.button_prev_next(qdata, APP.is_btn_click);
			if ( APP.is_btn_click !== 0 )
				APP.is_redraw = true;
			if ( ! APP.is_autonext )
				APP.is_btn_click = 0;
		}

		// update/redraw only when changed
		if ( APP.is_redraw || QUAD.gl.is_canvas_resized() ){
			APP.camera = QUAD.func.viewer_camera(qdata, APP.autozoom);
			APP.html.btn_cur.innerHTML = qdata.attach.id + '/' + qdata.anim_fps;
			APP.html.logger.innerHTML  = QUAD.func.console();

			QUAD.func.qdata_clear(qdata);
			QUAD.func.qdata_draw(qdata, APP.camera, APP.color);
			if ( ! qdata.is_draw ){
				APP.html.btn_cur.innerHTML = 'END';
			}
			APP.is_redraw = false;
		}

		APP.fps_draw = (APP.fps_draw + 1) & 0xff;
	}
	render();
})();
</script>

</body></html>
